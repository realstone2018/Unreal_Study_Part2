언리얼 이득우 강의 

C++만 안다고 언리얼 C++을 할수있는게아님 


★ 게임 프레임웍 
   - C++로 언리얼의 프레임웍 위에서 작업 또는 프레임웍 자체를구현할수 있어야함
   (유니티에서 툴을 만지는것 처럼)






1강. 헬로 언리얼! 
===========================================================================================================

작업환경 설치
----------------------------------------------------------------------------
에픽게임즈의 언리얼 설치옵션에서 디버깅을 위한 편집기 기호 설치 하기 

비주얼 어시스트를 실무에서는 같이 구매해서 사용하거나 라이더를 사용

비주얼스튜디오 다운시, 워크로드에서 "C++를 사용한 게임 개발" 다운 받기  


언리얼 세팅 
----------------------------------------------------------------------------
에디터/Editor Preference
   - 지역&언어 : 영어로 
   - SourceCode - Editor -> 정확한 비주얼 버전으로 지정해주기 


툴스 New C++ -> 모든 클래스  -> GameInstance 선택


비주얼 스튜디오
----------------------------------------------------------------------------
도구 - 옵션 - 환경 - 국가별 설정 - 언어 : 영어로 변경 

옵션 - 프로젝트앤 솔루션 - 제너럴 - Always show error list 언체크 

상단 메뉴바 오른쪽 클릭/Customize/Commands/Toolbar:Standard/Solution configuartions/우측의 Modify Selection 버튼 클릭/200으로 변경

언리얼 용 확장 도구 설치  
   - 비주얼 커맨더: https://bit.ly/visualcommander
   - 언리얼 인덴트 매크로 확장 도구: https://bit.ly/ue4vstool
   - Extensions/VCmd/Import/2017-2019임포트 (2019 이후버전 모두 호환)
   - Extensions/Vcmd/Extensions/기능 체크


비주얼 스튜디오 팁 
----------------------------------------------------------------------------
   Alt+Enter로 선언후 편하게 정의 가능 

   언리얼 코드 컴파일 방법 
      헤더파일에 변경이 발생 -> 에디터를 끄고 비주얼 스튜디오에서 컴파일 
      소스파일에만 변경 발생 -> 라이브 코딩으로 컴파일 (Ctrl+Alt+F11)

      <!> 절대 비주얼 스튜디오에서 수동으로 클래스를 추가하지 말것 

<!> 라이더는 언리얼 안꺼도 빌드 가능한듯? && 코파일러 ai인가? 가 가이드해줌 


예제 프로젝트 
----------------------------------------------------------------------------
0. 프로젝트 생성시 Project Defaults에서 c++로 변경하기 

1. GameInstance 만들기 
   - Tools/New C++ Class/AllClasses/GameInstance 검색 후 생성 


2. 연습용 프로젝트 세팅 
   - Project Setting / Maps&Modes -> GameInstance : 1.에서 생성한 myGameInstance로 변경 
      . GameInstance는 프로그램이 실행될 때마다 각자 하나씩 실행됨 
      . 엔진이 활성화되고 프로그램이 실행될 때 myGameInstance로 진행
   - 그리팩 계산을 끄기 위해, Edit/Project settings/Maps&Mode/Defualt맵 둘 다 클리어 
   - window - output log 체크해놔야 로그 확인 가능 


3. 디버깅 로그
   - 언리얼 끄고, 비주얼 스튜디오에서 Solution Explorer/Games/프로젝트이름/Source 아래 생성한 GameInstance 열기
   - 헤더파일 오버라이드 선언 후 Alt+Enter로 정의 자동 생성
      virtual void Init() override;

   -소스파일 
      void UMyGameInstance::Init() {
	      Super::Init();
	      UE_LOG(LogTemp, Log, TEXT("%s"), TEXT("Hello Unreal"));
      }

   - Ctrl+F5로 언리얼 실행

3. Play버튼 눌러 Output Log창에서 로그 보기(로그가 많으므로 검색)


언리얼 프로그래밍 팁 
----------------------------------------------------------------------------
UE_LOG() 
   - 언리얼에서 스트링 다룰 때 ""가아닌, 매크로 TEXT("")를 사용 








2강. 언리얼 C++ 코딩 규칙
===========================================================================================================
구글의 C++ 코딩 표준 

언리얼 C++ 코딩 표준 
https://docs.unrealengine.com/5.0/ko/epic-cplusplus-coding-standard-for-unreal-engine/
https://docs.unrealengine.com/5.3/ko/epic-cplusplus-coding-standard-for-unreal-engine/


기본적인 프로그래밍 규칙 
----------------------------------------------------------------------------
ㅇ클래스의 체계 
   - 읽는 사람은 대부분 클래스의 퍼블릭 인터페이스를 사용할 것이므로, 퍼블릭 인터페이스에서 먼저 선언한 후 클래스의 프라이빗 구현이 뒤따라야 합니다.
   - 항상 public: private: 구조를 잡고 시작하라 

ㅇ일반적인 C++가 다른, 언리얼 C++만의 네이밍 규칙
   - 일반적: 카멜 (unrealEngine) 
   - 언리얼 C++: 파스칼 케이싱 사용   (UnrealEngine) 

ㅇ클래스 이름, 접두사 규칙 
   - T: 템플릿클래스에는 
   - U: 언리얼 오브젝트를 상속받는 경우 
   - A: Actor의 경우
   - S: UI의 경우  
   - I: 추상형 인터페이스
   - E: 열거형
   - b: 부울형 변수  
   - F: 언리언 오브젝트를 상속하지 않는 일반 C++

ㅇ부울형을 반환하는 모든 함수는 Is~ 또는 Shold~ 처럼 (IsVisible(), ShoeldClear()) 

ㅇ변수
   - 인트형 변수 선언시, int 대신 int8 int16, ... 용량크기 지정 필요 (단 최소 32는 보장)
   - char -> TCHAR


ㅇ C++의 .h헤더파일에서 초기화 구문 사용, but 언리얼 U 오브젝트들은 생성자에서 초기화 구문 사용 


ㅇ모든 헤더는 #pragma once 지시어 세팅
   - 중복 Include 방지 (다이아몬드 구조등이 되었을 때 )


ㅇ * 
   - 사용시, FShaderType* type; 처럼  *바로 쓰고 한칸 띄우기 








3강. 언리얼 C++ 기본타입과 문자열
===========================================================================================================
강의목표 
----------------------------------------------------------------------------
언리얼 환경에서 알아두어야 할 기본 타입과 고려할 점
캐릭터 인코딩 시스템에 대한 이해
언리얼 C++이 제공하는 다양한 문자열 처리 방법과 내부 구성의 이해


예제 프로젝트
----------------------------------------------------------------------------
1. GameInstance 생성 
   - Tools/new C++ Class/All Classes/GameInstance 검색

2. Edit/Project Settings/Map&Mode
   - Default Map Clear
   - GameInstance 변경 


언리얼 C++ 기본타입
----------------------------------------------------------------------------
ㅇ언리얼은 C++의 기본타입이 아닌, 별도의 타입 사용 (int32, TCHAR, ....)

ㅇint의 경우 사이즈를 지정해줘야함  (int32, int64, ....)

ㅇfloat, double의 경우 국제 표준으로 지정되어있어, 별도 사이즈 지정 필요 없음 


캐릭터 인코딩 (TCHAR)
----------------------------------------------------------------------------
ㅇ공식 사이트 설명: https://bit/ly.uecharen

ㅇ언리얼 TCHAR은 UTF-16을 사용 

ㅇ외부 텍스트 파일을 로드할 때, UTF-16으로 파일을 로드 
   - 외부 파일들은 UTF-16으로 사용 권장 (.INT, .INI파일)
   - 어쩔수 없이 한글이 포함되어 있다면 UTF-8로 (권장하진 않음)


FString
----------------------------------------------------------------------------
ㅇ 문자열을 다양하게 조작할시에는 FString사용 
   - 문자열 출력시 * 포인터 연산자 잊지 말기 

ㅇ 문자열은 항상 TEXT매크로를 사용해 지정 
   - TEXT 매크로 내부에서 UTF-16로 반환해줌  

ㅇ 공식 사이트: https://bit.ly/uefstringkr

ㅇ 사용 예시
   - FString Test = FString(TEXT("Test FString."));


ㅇ 구조
   - TEXT("HELLO") -> TCHAR포인터 배열에 담김 
   - FString의 경우 TCHAR 동적 배열 (TArray)에 담김
   - *연산자를 붙여주면 TArray가 TCHAR 형태로 변환된다. 
   - 내부 문자열을 가공하는건 FCString에서 진행
      . FCString : C라이브러리 스트링 관련 함수들 래퍼 클래스 



FName
----------------------------------------------------------------------------
ㅇ에셋 관리를 위해 사용되는 문자열 체계 
   - 대소문자 구분 없음 
   - 해시테이블을 사용해서 빠름 
   - 소유 스트링 테이블에 대한 인덱스와 인스턴스 키값이 저장됨 
   - 한번 선언되면 Key로 만들어지기 때문에 바꿀수 없음 

※ FText : UI에서 다국적 이우너을 위한 문자열 관리 체계

ㅇ구조 
   - FName들을 저장하기 위한 싱글톤으로 되어있는 글로벌 풀을 가지고있다. [FNamePool]
   - FNamePool은 Key, Value 쌍으로 구성 

ㅇ주의점 
   - 반복문등 빈번하게 FName(TEXT("lelvis")); 이런 식이 자주 호출되면 
     key가 전역pool에 있는지 작업으로 오버헤드가 발생할 수 있음 


마무리 정리 
----------------------------------------------------------------------------
ㅇ언리얼이 C++타입 int를 사용하지 않는 이유 
   - C++ 규약에서 int는 "최소" 32비트를 보장하도록 규정 
      -> "최소"임으로 특정 플랫폼에 따라 64bit일수도 있어 int의 크기를 확실할수 없음 
ㅇ다양한 캐릭터 인코딩 시스템의 이해
ㅇ언리얼의 문자열 처리의 이해
ㅇFSTring의 구조와 사용방법
ㅇFName의 구조와 사용방법 


비주얼 스튜디오 팁 
----------------------------------------------------------------------------
IntelliSense(켰을 때 로딩)이 오래걸린다면, 언리얼 및 스튜디오 종료 후 
스튜디오 .sin 프로젝트 파일로 다시 열기 







4강. 언리얼 오브젝트 기초 
===========================================================================================================
강의 목표
----------------------------------------------------------------------------
게임 프로그래밍이 가지는 특수성과 언리얼 오브젝트의 필요성의 이해
언리얼 오브젝트의 선언과 엔진 내부 컴파일 과정의 학습 


C++의 게임 프로그래밍 이점 
----------------------------------------------------------------------------
ㅇ메모리를 직접제어
ㅇCache의 활용 극대화
ㅇ저수준 API의 직접 호출
ㅇ복사 작업의 최소화


모던 객체 지향 설계 원칙 
----------------------------------------------------------------------------
ㅇ디자인 패턴을 필두로 안정적인 설계 방법이 연구됨 

ㅇ현재 시점에서 모던이라 보기엔 무리 

ㅇ유지보수와 유연함, 확장성 향상을 위한 객체지향 프로그래밍원칙 (SOLID)
   - Single responsibility principle : 하나의 클래스는 하나의 책임만 가져야 한다
   - Open/cosed principle: 클래스 설계를 변경하지 않고 동작을 확장할 수 있어야 한다.
   - Liskov substitution principle: 자식 클래스는 부모 클래스를 대체 사용할 수 있어야한다.
   - Interface segregation principle: 작고 명확한 인터페이스들로 분리해 관리해야 한다
   - Dependency inversion principle: 구현을 배제시킨 상위 정책을 바라보며 설계해야한다.


언리얼의 C++
----------------------------------------------------------------------------
ㅇ후발 언어(C+ java)등이 보완한 새로운 기능 (C++에는 없는 기능)
   - 인터페이스: 객체 설계의 틀을 제공하는 추상클래스
   - 리플렉션: 런타임에서 객체의 구조를 파악하고 객체에 메타데이터를 부여
   - 딜레게이트: 프로그램에서 발생한 이벤트를 다수의 객체에 효과적으로 전달하는데 활용

ㅇ언리얼의 C++
   - 언리얼은 모던 객체지향 설계을 위해, C++에 없는 기능들을 자체로 구현


언리얼 오브젝트
----------------------------------------------------------------------------
ㅇ언리얼 엔진이 C++언어를 확장한 객체 구조(시스템 단위 오브젝트)
   - 기존 c++ 오브젝트에 모던 객체 지향 설계를 위한 다양한 기능의 추가한 오브젝트
   - 일반 c++ 오브젝트와 언리얼 오브젝트의 두 객체를 모두 사용할 수 있음
   - 구분을 위해 일반 C++ 오브젝트는 접두사F, 언리얼 오브젝트는 접두사 U를 사용함
   
ㅇ각 오브젝트 사용 용도 
   - C++ 오브젝트: 저수준의 빠른 처리를 위한 기능 구현에 사용
   - 언리얼 오브젝트: 콘텐츠 제작에 관련된 복잡한 설계 구현에 사용

ㅇ언리얼 사이트 오브젝트 설명: https://docs.unrealengine.com/5.1/ko/objects-in-unreal-engine/


예제 프로젝트 
----------------------------------------------------------------------------
new C++ class / All / Object 생성 

헤더코드
   -언리얼 오브젝트를 뜻하는 UMyObject가 생성됨 확인 
      .파일이름에 U가 붙는게 아님 
   - UNREALOBJECT_API 확인 
      .다른 모듈에서 UMyObject 접근을 위한 api

[오브젝트이름.generated.h] 헤더 파일 
   - #include "MyObject.generated/h" 
   - 모던 객체지향 설계를 위해 언리얼에서 기본적으로 지원해주는 오브젝트 기능들

언리얼 헤더 툴 
   - 빌드시 오브젝트 이름.generated.h 헤더파일을 생성
   - 헤더에 선언된 지정된 매크로들을 참조하여 빌드시
     관련기능의 코드를 자동 추가 





5강. 언리얼 오브젝트 리플렉션 시스템1 
===========================================================================================================
강의 목표 
----------------------------------------------------------------------------
언리얼 오브젝트의 특징과 리플렉션 시스템의 설명
언리얼 오브젝트의 처리방식의 이해


리플렉션
----------------------------------------------------------------------------
ㅇ공식 : https://www.unrealengine.com/ko/blog/unreal-property-system-reflection
   - C++에서 지원되지 않아 언리얼이 자체 구현한 언리얼의 핵심 기능 
   - 지정 매크로 지정하여 generated.h 헤더파일에 포함되어 사용 가능

ㅇ공식 : https://docs.unrealengine.com/5.1/ko/unreal-object-handling-in-unreal-engine/


언리얼 오브젝트의 구성 
----------------------------------------------------------------------------
언리얼 오브젝트에는 특별한 프로퍼티와 함수를 지정할 수 있음
   .관리되는 클래스 멤버 변수 : UPROPERTY
   .관리되는 클래스 멤버 함수 : UFUNCTION
   . 에디터와 연동되는 메타데이터를 심을수 있음

모든 언리얼 오브젝트는 클래스 정보(UClass)와 함께 함
   .클래스를 사용해 자신이 가진 프로퍼티와 함수 정보를 컴파일 타임과 런타임에서 조회할 수 있음
   .  런타임시 GetClass() / 컴파일타임시 StaticClass()로 언리얼 오브젝트에서 가져올 수 있다.

이렇게 다양한 기능을 제공하는 언리얼 오브젝트는 NewObject API를 사용해 생성해야함
   - 일반 c++객체는 new()
   - 언리얼 오브젝트는 NewObject() 


언리얼 오브젝트의 클래스 기본 오브젝트 (CDO: Class Default Object)
   - 언리얼 클래스 정보(UClass)에는 클래스 기본 오브젝트가 함께 포담되어 있다.
   - CDO는 언리얼 객체가 가진 기본 값을 보관하는 템플릿 객체
   - 한 클래스로부터 다수의 물체를 생성해 게임 콘텐츠에 배치할 때 일관성 있게 기본값을 조정하는데 유용하게 사용
   - CDO는 클래스 정보로 부터 GetDefaultObject 함수를 통해 얻을 수 있음
   - UClass 및 CDO는 엔진 초기화 과정에서 생성되므로 콘텐츠 제작에서 안심하고 사용할 수 있음


https://www.unrealengine.com/ko/blog/unreal-property-system-reflection


https://docs.unrealengine.com/5.1/ko/unreal-object-handling-in-unreal-engine/


자주 사용 하는 매크로 
   - UPROPERTY() : 포인터등을 사용할 때, 언리얼이 자동으로 메모리를 관리해줌 (가비지 컬렉터)
      . 선언하지 않을 경우, 할당 및 해제가 자동으로 되지않아 주의 필요 
      . 생성자 호출 전 초기화시 가비지값이 아닌 기본값으로 채워진다.
      . UPROPERTY 속성이 붙은 변수를 리플렉스 시스템을 사용하여 런타임이든 컴파일 타임이든 언제든지 가져올수 있게됨 

       

언리얼 C++ 프로그래밍 팁 
----------------------------------------------------------------------------
ㅇ언리얼의 어설션 함수
   -check() 
      .단 빌드 실패시 언리얼 에디터가 꺼짐 

   -ensure()
      .에디터가 꺼지지 않음 
      .언리얼에디터에서 실행시 에러로그로 출력됨

   -ensureMsgf(조건, TEXT("에러 로그"))
      .에러로그로 지정된 문자열이 출력됨 


정리 
-언리얼 오브젝트에는 항상 클래스 정보를 담는 UClass객체가 매칭
-UClass로부터 언리얼 오브젝트의 정보를 파악할 수 있다
-UClass에는 클래스 기본 오브젝트(CDO)가 연결되어 있어 이를 활용해 개발의 생산성을 향상시킬 수 있다
-클래스 정보와CDO는 엔진 초기화 과정에서 생성되므로 게임 개발에서 안전하게 사용 가능
-헤더 정보를 변경하거나 생성자 정보를 변경하면(CDO) 에디터를 끄고 컴파일하는것이 안정적이다.








6강. 언리얼 오브젝트 리플렉션 시스템2
===========================================================================================================
강의 목표
언리얼 오브젝트 리플렉션 시스템을 사용해 언리얼 오브젝트를 다루는 방법의 학습



언리얼 오브젝트에서 #include 추가시, 항상 generated.h가 가장 아래 와야 한다.

cpp파이르이 include 순서의 경우 
해당 언리얼 오브젝트의 선언된 헤더가 가장 위에 위치해 있어야한다.

MyGameInstance.cpp에서 #include 중에  
#include "MyGameInstance.h"이 가장 첫번재로 와야 한다. 


정리, 언리얼 리플렉션 시스템의 활용
1.리플렉션 시스템을 사용해 언리얼 오브젝트의 특정 속성과 함수를 이름으로 검색할 수 있다.
2.리플렉션 시스템을 사용해 접근 지시자와 무관하게 값을 설정할 수 있다.
3. 리플렉션 시스템을 사용해 언리얼 오브젝트의 함수를 호출할 수 있다.

언리얼 엔진읭 기본 프레임웍은 리플렉션을 활용해 구축되어 있으므로
언리얼 엔진을 이해하기 위해서는 리플렉션 시스템을 이해하는 것이 필요함.







7강. 언리얼 C++ 설계 1 - 인터페이스 
===========================================================================================================
강의 목표 
----------------------------------------------------------------------------
언리얼 c++인터페이스 클래스를 사용해, 보다 안정적으로 클래스를 설계하는 기법의 학습 


언리얼 C++ 인터페이스
----------------------------------------------------------------------------
인터페이스란
   - 객체가 반드시 구현해야 할 행동을 지정하는데 활용
   - 같은 상속 부모를 가져도, 객체 별 구분되는 동작이 반드시 구현해야할 내용은 인터페이스로 빼기도 한다.
   - 인터페이스 상속여부를 통해, 객체마다 특정동작(인터페이스에서 정의한) 가능 여부를 구분할수도 있다.

특징 
   - 인터페이스를 생성하면 두 개의 클래스가 생성됨 
      - UInterface
         . 클래스 타입 정보의 제공
         . U타입 클래스 정보는 런타임에서 인터페이스 구현 여부를 파악하는 용도로 사용됨

      - IInterface : 실질적인 설계 및 구현
   
   - 언리얼은 내부적으로 c++의 클래스로 인터페이스를 구현해서, 기본 로직 구현가능 


액터 
----------------------------------------------------------------------------
   - 월드에 배치되는 모든 오브젝트 
   - 움직이는 엑터를 위한 오브젝트 (Pawn 폰)




언리얼 팁 
----------------------------------------------------------------------------
탐색기에서 프로젝트의 구성을 변경한 경우 
Tools에서 Refresh Visual Studio ....를 눌러주면 된다 

언리얼의 경우 형변환시 변환이 적용되지 않으면 null을 반환한다. 
   - 그로인해 ~~를 알 수 있다.


언리얼 C++팁
----------------------------------------------------------------------------
헤더에서 함수 정의가 올 수도 있다. (전처리로 인해... C++ 윤성우책에서 봣떤것 같은데)
 <♣> 찾아보기 

새로본 매크로 
   - FORCEINLINE



실습 
----------------------------------------------------------------------------
다른 프로젝트의 헤더와 코드를 가져올때는
1.복사
2.Tools / Refresh Visual Studio
3.전처리문 (외부 모듈이 언리얼 인터페이스의 클래스인 UMyInterface 접근을 위한)을 
    UnrealInterfaceGameModeBase.h 에서 가져와 수정 
   예제에선 : OBJECTREFLECTION_API -> UNREALINTERFACE_API 



인터페이스 생성
   new C++ Class / Common Class 아래쪽 / Unreal Interface를 선택하여 생성한다. 

   //abstract 가상함수 선언 -> 인터페이스를 상속받는 클래스들은 DoLesson 클래스 구현 강제
   virtual void DoLesson() = 0;
	//언리얼 인터페이스 특성상 구현도 가능하다 -> 이 경우 상속 클래스들에서 구현이 강제되지 않음 



상속과 인터페이스 둘 다 있는 경우, Super로 인터페이스의 상위에 접근할 수 없다. 
클래스 정보에 대해선 단일 상속만 지원됨.
(예제: Student에서 Super:: 접근시 UPerson으로 접근 / ILessonInterface로 접근하지 않는다)

이경우 직저 호출해줘야 함 (예제: ILessonInterface::DoLesson(); )






정리 
언리얼C++ 인터페이스를 사용하면, 클래스가 수행해야 할 의무를 명시적으로 지정할 수 있어 좋은 객체 섫계를 만드는데 도움을 줄수 있다.















8강. 언리얼 C++ 설계 2 - 컴포지션 
===========================================================================================================
강의 목표
---------------------------------------------------------------------------- 
언리얼 C++의 컴포지션 기법을 사용해 오브젝트의 포함 관계를 설계하는 방법의 학습 
언리얼 C++이 제공하는 확장 열거형 타입의 선언과 활용 방법의 학습


객체지향에서의 컴포지션
---------------------------------------------------------------------------- 
   - Has-A관계
   - 복합적인 기능을 가진 거대한 클래스를 효과적으로 설계하는데 유용하게 사용할 수 있음 


언리얼 엔진에서의 컴포지션 
----------------------------------------------------------------------------
하나의 언리얼 오브젝트에 다른 언리얼 오브젝트를 조합할 때 다음의 선택지
   1. CDO에 미리 언리얼 오브젝트를 생성해 조합 (필수적 포함)
      . 컴파일 타임 때 
      . CreateDefaultSubobject()
      . 생성자 코드에서 작업 
   
   2. CDO에 빈 포인터만 넣고 런타임에서 언리얼 오브젝트를 생성해 조합 (선택적 포함)
      . 런타임 타임 때 
      . 서브오브젝트는 NewObject()로 생성

언리얼 오브젝트를 생성할 때 컴포지션 정보를 자동으로 구축해준다.
   - 내가 소유한 언리얼 오브젝트를 Subobject라고 한다.
   - 나를 소유한 언리얼 오브젝트를 Outer라고 한다. 



<?> 컴포넌트와 컴포지션 
   - 컴포지션 : 멤버로 다른 Class를 Has-A관계를 만든느 설계 기법 
   - 컴포넌트 : 조합할수 있는 개별 요소 단위 용어
   - 컴포지트 패턴 vs 컴포넌트 패턴
      . 컴포넌트 패턴 : 여러 분야를 다루는 하나의 개체가 있다. 분야별로 격리하기 위해, 각각의 코드를 별도의 컴포넌트 클래스에 둔다. 이제 개체 클래스는 단순히 이들 컴포넌트들의 컨테이너 역할만 한다.
      . 컴포지트 패턴 : 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴




실습 
----------------------------------------------------------------------------

새로보는 매크로 
   - UENUM()


C++의 열거형
   - 선언 시, 접두사로 E붙이기
   - 선언 시, 일반적으로 uint8 (바이트 타입)
   - ECardType::Teacher 형태로 사용한다

언리얼 열거형 
   - C++의 열거형을 확장
   - UENUM() 
   - 필드마다 메타정보 적용 가능   
      . UMETA(DisplayName = ""),
   - 메타정보를 가져올때
      . FindObject<UEnum>(nullptr, TEXT("절대 주소값"));
   


컴포지션 선언 방식
   - 4와 5의 권장하는 선언 방식이 다르다.  
   - 선언에서만, 구현에서는 ㄱㅊ 

4의 방식 : 전방선언 
   UPROPERTY()
   class UCard* Card;

전방선언
   - 헤더를 포함하지 않고 포인터로 관리하여, 의존성을 없앨수 있음 
   - <♣> 검색해보기 

5의 방식  
   UPROPERTY()
   TObjectPtr<class UCard> Card;


언리얼 팁 
----------------------------------------------------------------------------
비주얼스튜디오에서 소스코드와 헤더를 Remove해도 탐색기에는 남아있고,
언리얼 프로젝트를 열수 없게 된다. 


프로그래밍 팁 
----------------------------------------------------------------------------
일반 string이 아닌 FName인 경우 (FName매개변수의 인자로 TEXT()를 넘기는 경우) Name으로 시작하기
   - ex. NAME_Card
	
<♣> 포인터에서의 const 복습하기 
   - FORCEINLINE const FString& GetName() const  { return Name; }



정리 
----------------------------------------------------------------------------
   1. 언리얼 c++은 컴포지션을 구현하는 독특한 패턴이 있다.  
   2. 클래스 기본객체를 생성하는 생성자 코드를 사용해 복잡한 오브젝트를 생성할 수 있음 
   3. 언리얼 C++컴포지션의 Has-A 관계에 사용되는 용어 










9강. 언리얼 C++ 설계3 - 델리게이트 
===========================================================================================================
강의 목표 
----------------------------------------------------------------------------
느슨한 결합의 장점과 이를 편리하게 구현하도록 도와주는 딜레깅트의 이해
발행 구독 디자인 패턴의 이해
언리얼 델리게이트를 활용한 느슨한 결합의 설계와 구현을 학습 



강한 결합 (Tight Coupling)
----------------------------------------------------------------------------
클래스들이 서로 의존성을 가지는 경우
아래 예시에서 Card가 없는 경우 Person이 만들어 질수 없다
이 때 Person은 Card에 대한 의존성을 가진다고 한다


느슨한 결합 (Loose Coupling) <- 인터페이스가 가지는 장점
----------------------------------------------------------------------------
실물에 의존하지 말고 추상적 설계에 의존 (DIP 원칙)
추상적 : Person이 출입을 위해 Card 객체를 가지고 있어, Person과 Card간의 의존성이 강함
        이 경우, 다른 출입 방식인 지문이 도입되어 스태프는 카드를, 직원은 지문을 가지는 식이 되면 복잡해진다
        실물인 Card가 아닌, "출입"의 추상적인 기능을 ICheck 인터페이스로 연결
        - Card는 ICheck 인터페이스를 상속 /  Person은 Card가 아닌 ICheck 멤버 객체를 가진다 

단 매번 인터페이스를 만드는것이 번거롭거나 오버스펙일 때, 행동 자체를 오브젝트로 관리 -> 델리게이트 
   - C의 함수포인터를 활용한 콜백은 기능 사용 자체가 복잡하고 안전성 검사가 따라야함
   - C++ 17 구약의 std::bind와 std::function은 퍼포먼스가 떨어져 게임에 비적합 
   - C#의 델리게이트 키워드 : 함수를 객체 처럼 다룰수 있음
   -> 언리얼 C++에서 C#의 델리게이트 방식 지원 


느슨한 결합의 간편한 구현 - 델리게이트 
----------------------------------------------------------------------------
델리게이트 공식 문서 : https://docs.unrealengine.com/5.1/ko/delegates-and-lamba-functions-in-unreal-engine/
   - 공식 문서 볼 때는, 버전 5.3으로 변경해서 보기 
   - C#과 다소 다름
   - 문서 읽어보기 

델리게이트의 속성에 따라 매크로를 지정해 줘야함 
바인딩(콜백함수 연결)시 함수를 통해 
   - BindUObject() : 일반적으로, UObject 기반 멤버함수를 사용해서 엮어주는 방식 사용

페이로드 데이터 
   - ? 아마도: 객체를 묶을 때, 추가 속성을 지정 가능

델리게이트 실행 
   - 일반 함수호출 하는 C#과 다르게 (Null에러 방지를 위해 Invoke를 하기도 하지만) 
     언리얼 C++에서는 델리게이트 속성에 따라 다른 함수 호출 (Excute / Broadcast)

용도 
   - 특정 오브젝트 (같은 Class라 할지라도)만 이벤트를 받아 콜백을 호출해야하는 경우


언리얼 델리게이트 선언 시 고려사항
----------------------------------------------------------------------------
인자 수와 각각의 타입
   - 몇개
   - 어떤 방식
   - 일대일 or 일대다

프로그래밍 환경 설정
   - C++프로그래밍 함수만 연결?
   - UFUNCTION으로 지정된 블루프린트함수와 연결?

함수와의 연결 형태 
   - 클래스 외부에 설계된 C++ 함수와 연결
   - 전역에 설계된 정적함수와 연결
   - 언리얼 오브젝트 멤버 함수와 연결 (일반적인 경우) 


DECLARE_{델리게이트 유형}DELEGATE{함수정보}

델리게이트 유형
   - 일대일 형태로 c++만 지원 : DECLARE_DELEGATE
   - 일대다 형태로 c++만 지원 : DECLARE_DYNAMIC
   - 일대일 형태로 블루프린트 지원 : DECLARE_DYNAMIC 
   - 일대다 형태로 블루프린트 지원 : DECLARE_DYNAMIC_MULTICAST 

함수정보 
   - 인자, 반환값 둘 다 없음 : DECLARE_DELEGATE
   - 인자가 하나, 반환값 X : DECLARE_DELEGATE_OneParam
   - 인자가 셋, 반환값 o : DECLARE_DELEGATE_ReVal_ThreeParams

! 일대다(MULTICAST)의 경우 반환값 (Reval)을 지원하지 않는다.
! 파라미터는 최대 9개까지 지원 

예시
   - DECLARE_MULTICAST_DELEGATE_TwoParams : 두개의 인자를 다수의 인원에게 전달하며, C++만 지원 



발행 구독 디자인 패턴 
----------------------------------------------------------------------------
푸시형태의 알림을 구현하는데 적합한 디자인 패턴 

발행자와 구독자로 구분
   - 콘텐츠 제작자는 콘텐츠를 생산
   - 발행자는 콘텐츠를 배포
   - 구독자는 배포된 콘텐츠를 받아 소비
   - 제작자와 구독자가 서로 몰라도, 발행자를 ㅗ통해 콘텐츠를 생산하고 전달 (느슨한 결합)

장점
   - 제작자와 구독자는 서로 모르기 때문에 느슨한 결합
   - 유지보수(Maintenance)와 유연함(Flexibility) 확립 





실습 
----------------------------------------------------------------------------
딜레게이트 네이밍 때 접미사로 보통 Signature를 붙임 

UPROPERTY를 선언하지 안아도 되는 경우
   - 메모리를 동적관리할일 없고 
   - 블루푸린트 x
   - 속성을 리플렉션을 통해서 참조할 일이 없다면 


CourseInfo와 Student 어디에서도서로 참조하지 않는다.
중간다리인 MyGameInstance이 대신함


헤더나 소스코드에 CourseInfo.h 헤더가 포함되지 않음 
중간에서 링크해주는 객체 -> MyGameInstance


TObjectPtr을 이용한 전방선언 
CourseInfo는 언리얼 오브젝트로 포인터로 관리됨.
->포인터로 관리하기 때문에 전방선언을 사용할 수 있음.
->선언에서 언리얼 오브젝트의 포인터를 멤버변수로 지정할 때는 TObjectPtr 사용


생성자로 오브젝트를 넘겨 SubObject, Outer 설정이 가능하다
	//Outer로 MyGameInstance를 넘겨준다.  -> UCourseInfo는 MyGameInstance의 SubObject가 됨 
	CourseInfo = NewObject<UCourseInfo>(this);



<!> 함수는 등록한 순서의 역순으로 호출된다.
	CourseInfo->OnChanged.AddUObject(Student1, &UStudent::GetNotification);
	CourseInfo->OnChanged.AddUObject(Student2, &UStudent::GetNotification);
	CourseInfo->OnChanged.AddUObject(Student3, &UStudent::GetNotification);

   LogTemp: [Student] 학생3님이 학교로부터 받은 메세지 : 변경된 학사 정보
   LogTemp: [Student] 학생2님이 학교로부터 받은 메세지 : 변경된 학사 정보
   LogTemp: [Student] 학생1님이 학교로부터 받은 메세지 : 변경된 학사 정보








10강. 언리얼 컨테이너 라이브러리 1 - Array와 Set
===========================================================================================================
강의목표 
----------------------------------------------------------------------------
-언리얼 대표 컨테이너 라이브러리 TArray, TSet의 내부 구조 이해
-각 컨테이너 라이브러리의 장단점을 파악하고, 알맞게 활용하는 방법의 학습 



언리얼 컨테이너 라이브러리 
----------------------------------------------------------------------------
-UCL(Unreal Container Library) 
-언리얼 엔진이 제작해 제공하는 자료구조 라이브러리
-자주사용하는 라이브러리 : TArray, TMap, TSet
-접두사 T는 Template Library를 의미 



C++ STL과 언리얼 컨테이너 라이브러리의 차이점 
----------------------------------------------------------------------------
-C++ STL은 범용적이며 호환성이 높지만, 그 만큼 많은 기능이 들어있어 컴파일 시간이 오래걸림
-언리얼 컨테이너 라이브러리는 언리얼 엔진 특화로, 언리얼 오브젝트 구조를 안정적으로 지원

ㅇ주요 라이브러리 차이
-TArray : 오브젝트를 순서대로 담아 관리
-TSet : 중복되지 않은 요소로 구성된 집합
-TMap : Key, Value 쌍의 레코드 관리  

ㅇSTL의 
   -vector -> TArray
   -set -> TSet
   -map -> TMap
   -단 TSet과 TMap은 내부적으로 다르게 구현되어있음 


유니티 C#의 (<?> 추측임)
   -list -> TArray
   -HashSEt -> TSet
   -Dictionary -> TMap


TArray의 구조와 활용
----------------------------------------------------------------------------
가변 배열 (Dynamic Array, 동적 배열) 자료구조를 가진다
가변 배열의 단점인, 중간에 요소를 추가하거나 삭제 작업은 비용이 크다 
데이터가 크고 검색, 삭제, 수정 작업이 자주 일어난다면 TArray보다는 TSet을 권장 

ㅇ자주사용되는 함수 
   - GetData(): 배열의 시작주소를 가져옴
   - Array[]: 인덱스를 이용한 요소접근 (배열의 의의), 레퍼런스를 반환함으로 요소를 변경 가능
   - Add(), Emplace(), Append(): 배열의 끝에 추가  
      . Add(): 추가할 데이터를 외부에서 생성 후, TArray에 복사하여 추가
      . Emplace() : TArray자체에서 데이터를 생성 (Add의 복사 연산이 없음, Add보다 사용 권장됨)
         (+＠ 가독성으로 Add가 사용되기도 하지만, 반복문이나 데이터가 큰 경우 Emplace())
   - InSert(): 중간 삽입
   - SetNum(): 배열의 크기를 줄이거나 늘림
   - Empty() : 모든 요소 제거 (C#의 Clear()의 기능)


ㅇ공식 홈페이지 URL: 
   - TArray는 값 유형(Value Type)이다
      -> new 및 delete로 생성 또는 소멸을 권장하지 않음 (보통 클래스 멤버 변수나 스택에서 자연스럽게 소멸한다.)
      -> 다른 TArray변수에서 참조하지 않음, 항상 값복사로 이루어진다
      -> TArray의 소멸은 엘리먼트(요소)의 소멸을 동반한다.
         (다른 TArray에서 참조해서 그쪽에서 null이 되거나 해당 엘리먼트의 소멸이 보류되는 경우가 없다.) 

   - CreateInteractor(): 반복문에서, 요소에 읽기-쓰기 가능
   - CreateConstInteractor(): 반복문에서, 요소 읽기만 가능
      (+@ Ranged For문 (일반적인 for문)에서 const를 붙여 읽기전용 순회를 할 수 있다.)
   - Num() : 요소를 카운트 (언리얼 C++에서는 Count대신 사용됨)

   - 유효하지 않은 인덱스에 접근시 오류 발생, IsValidIndex()함수를 사용 후 접근

   - 슬랙
      .실제 사용되는 메모리보다 크게 할당하여, 추가작업때마다 메모리를 새로 할당하는 비효율을 방지 
      .이때 할당된 여유분을 '슬랙'이라 부른다 

   - 슬렉 관리, 원시 메모리 관리 등 딥한 부분들도 다루니 시간이 될 때 읽기 


ㅇ 사용 팁 
   - Find로 순회검색을 해야하는 경우가 잦다면 TArray보다는 TSet이 적합한 자료구조다.
   - TArray 내부에 포인터가 올 땐 반드시! 필수적으로!, UPROPERTY() 붙여줘 자동으로 메모리 관리되도록 하기
   - Int32Array += {2, 4, 6, 8, 10}; 와 같이 += 연산으로 여러 요소를 뒤쪽에 추가 가능



TSet의 구조와 활용
----------------------------------------------------------------------------
ㅇSTL Set의 특징
   -내부적으로 이진트리로 구현되어, 정렬을 지원함
   -이진트리 단점으로, 메모리 구성 효율이 나쁨 (요소가 삭제될 때 이진트리 재구축)
   -이진트리 단점으로, 모든 자료를 순회하는데 적합하지 않음

ㅇ언리얼 TSet의 특징
   -내부적으로 해시테이블 형태, 키데이터가 구축되어 있어 빠른검색 
   -동적배열의 형태로 빠른 순회 / 요소가 삭제되어도 재구축 x
      (+@ 정확히는 Sparse Array 자료구조 기반)
   -요소로 비어있는 데이터가 있을 수 있다.

ㅇ공식 홈페이지 URL: 
   - TSet은 데이터 값 자체를 키로 사용한다. (해시테이블 특징)
   - TSet이 소멸하면, 엘리먼트(요소)들도 소멸된다.

   - 커스텀 구조체를 사용해서 TSet을 만드는 경우 operactor == 와 GetTypeHash 함수를 오버라이드 하여 구현해 줘야 한다. 

   - CreateInteractor(): 반복문에서, 요소에 읽기-쓰기 가능
   - CreateConstInteractor(): 반복문에서, 요소 읽기만 가능
      (+@ Ranged For문 (일반적인 for문)에서 const를 붙여 읽기전용 순회를 할 수 있다.)
   - Num() : 요소를 카운트 (언리얼 C++에서는 Count대신 사용됨)

   - 지정한 엘리먼트가 있는지 확인할 때 Contains() 사용 (TArray의 Find()보다 월등히 빠르다)
   - FSetElementId구조체를 사용하여 TSet 인덱스에 접근 가능 ([]연산자와 같이 사용하여)

   - 슬랙 
      . TArray와 마찬가지로 여유 공간이 뒤쪽에 있지만 
      . TSet은 제거된 인덱스는 Invalid 상태로 있다가 추가때 뒤에서부터 해당 공간에 추가함으로, 중간중간에도 슬랙이 존재한다.      

	Int32Set.Remove(2);
	Int32Set.Remove(4);
	Int32Set.Remove(6);
	Int32Set.Remove(8);
	Int32Set.Remove(10); //{1, Invalid, 3, Invalid, 5, Invalid, 7, Invalid, 9, Invalid }

	Int32Set.Add(2); //{1, Invalid, 3, Invalid, 5, Invalid, 7, Invalid, 9, 2 }   뒤에서 부터 채워진다

   -> TSet은 순서에 의미가 없는, 무작위 순서의 데이터 집합으로 생각해야함 


ㅇ 사용 팁 
   - 중복키를 할당하면, 아무 변화 없다. (에러도 없는듯?)
   - TSet내 엘레멘트가 있는지 확인하기 위해 Contains와 []연산자를 이용할 수는 있지만 비효율적 (검색연산이 두번 일어난다.)
     대신하여, Find() 권장 (없는 경우 nullptr 널 포인터 반환됨)
   - TArray와 마찬가지로 다른 TSet에 대입연산시 복사가 이루어진다.


TArray와 TSet 비교 
----------------------------------------------------------------------------
TArray: 빈틈없는 메모리, 가장 높은 접근과 순회 성능
접근: O(1)
검색: O(N)
삽입: O(N)
삭제: O(N)

TSet : 빠른 중복 감지, Invalid가 중간중간 있을수 있어 순회에 부적합
접근: O(1)
검색: O(1)
삽입: O(1)
삭제: O(1)


언리얼 C++ 팁 
----------------------------------------------------------------------------
FString의 비교 연산에서, 대소문자는 구별되지 않는다.


언리얼 팁 
----------------------------------------------------------------------------
비주얼 스튜디오에서 DebugGame Editor 모드로 변경해야, 디버깅 시 TArray 내부 값들을 볼 수 있다. 












11강. 언리얼 컨테이너 라이브러리 2 - 구조체와 map
===========================================================================================================
강의 목표
언리얼 구조체의 선언과 특징 이해
언리얼 대표 컨테이너 라이브러리 TMap의 내부 구조 이해
세 컨테이너 라이브러리의 장단점을 파악하고, 알맞게 활용ㅎ


언리얼 구조체 UStruct
----------------------------------------------------------------------------
데이터 저장/전송에 특화된 가벼운 객체
대부분 GENERATED_BODY 매크로를 선언 (꼭 해줘야 하는건 아님)
   - 리플렉션, 직렬화 등 여러 유용한 기능 사용
   - GENERATED_BODY를 선언한 구조체는 UScriptStrict클래스로 구현된다
      . 이경우, 제한적으로 리플렉션 지원(UPROPERTY만 가능, UFUNCTION은 불가능 -> 내부에서 함수 선언 불가)
   - 접미사 F
      . 대부분 힙 메로리 할당(포인터 연산) 없이 스택 내 데이터로 사용됨
      . NewObject API를 사용할수 없믐
      . 언리얼오브젝트와 다르게 인자를 가진 생성자 오버로딩 가능
기본 접근지시자 public 


ㅇ공식 홈페이지 URL: 
   -언리얼 오브젝트가 아니므로 F로 시작

   -기본 사용 방법
      //구조체 매크로 USTRUCT
      //BlueprintType, 블루프린트에서 해당 구조체 호환   
      USTRUCT(BlueprintType)
      struct FMyStruct {
         GENERATED_BODY()  //언리얼 오브젝트에서도 사용했던 매크로, 리플렉션을 통해 활용할수 있는 기본 뼈대 제공
          ....
      }

   -구조체에서 언리얼 오브젝트 포인터를 사용할 경우, UPROPERTY() 매크로를 붙여줘야만
    자동으로 메모리가 관리된다.

   -c++에서는 클래스와구조체의 차이는, 기본 접근 지시자의 차이 정도 (구조체: public / 클래스: private) 
    언리얼 c++에서는 언리얼 오브젝트와, USTRUCT가 붙은 언리얼 구조체는 사용 용도가 완전히 다름
    언리얼 구조체는 단순한 데이터타입에 적합

   -언리얼 구조체는 일반객체로 취급됨으로, 언리얼의 여러 기능의 대상에서 제외됨 (F로 시작)
    단 UPROPERTY()속성이 붙은 변수들은 언리얼 시스템의 기능들이 적용됨




TMap의 구조와 활용 
----------------------------------------------------------------------------
ㅇSTL map의 특징
   -STL Set과 동일하게 이진트로리 구성되어 있어
    정렬은 지원하지만, 메모리 구성이 효울적이지 않고 삭제시 재구축이 일어날 수 있다 
   -순회에 적합하지 않음

ㅇ언리얼 TMap의 특징
   -데이터의 TSet구조로 내부구조 및 메커니즘이 TSet과 동일
   -엘리먼트가 키, 밸류 구성의 튜플이라는점이 다름 (TPair)
   -TSet의 특징 및 장단점 그대로 (헤시테이블로 인한 빠른 검색, 동적배열 형태, 빠른 순회, 삭제해도 재구축 없음, 비어있는 데이터가 중간에 있을수 있음)
   -기본적으로는 중복을 허용하지 않으나, TMultiMap을 사용하면 중복 가능 

ㅇ공식 문서 URL: 
   -커스텀 구조체를 사용할 경우 TSet과 마찬가지로, operactor == 와 GetTypeHash 함수를 오버라이드 하여 구현해 줘야 한다. 
   -기본적으로는 키값을 활용해서 equal (==) 연산 실행
   -Iterator순회시 (for문) Key, Value로 접근한다. (C#의 Dictionary와 같은 방식)  

   -TSet과 마찬가지로, 
     엘리먼트가 있는지 확인하기 위해 Contains와 []연산자를 이용할 수는 있지만 비효율적 (검색연산이 두번 일어난다.)
     대신하여, Find() 권장 (없는 경우 nullptr 널 포인터 반환됨)
   
   -FindOrAdd(): Find후 해당 키값이 없다면 Add까지 한번에 진행 
      . Find면 Find / Add면 Add 디버깅 전까지 어떤 명령을 수행하는지 모르는 해당 함수는 권장하진 않음  

   -FindKey(): Value값으로 순회하며 Key를 역조회 
      . Key만 해쉬로 관리됨, Value를 순회하면 최악의 경우 O(n) 
      (+@ C#의 Dictionary에는 없던걸로 기억, Value로 역 조회를 해야한다면 Dictionary 자료구조가 맞지 않거나 잘못 설계된 케이스로 보기도한다)

   -기본적으로 TSet과 동일하지만, 예제가 잘 나와있으므로 읽어보기 

   -구조체 TMap의 경우 구조체의 특징상, 단순 ==만으로 처리 불가할 수 있음
      -> 이를 위해 KeyFunc 기능 지원



자료구조의 시간 복잡도  
----------------------------------------------------------------------------
TArray: 빈틈없는 메모리, 가장 높은 접근과 순회 성능
접근: O(1)
검색: O(N)
삽입: O(N)
삭제: O(N)

TSet : 빠른 중복 감지, Invalid가 중간중간 있을수 있어 순회에 부적합
접근: O(1)
검색: O(1)
삽입: O(1)
삭제: O(1)

TMap : 중복 불허, 키 밸류 관리
접근: O(1)
검색: O(1)
삽입: O(1)
삭제: O(1)

TMultiMap : 중복 허용, 키 밸류 관리
접근: O(1)
검색: O(1)
삽입: O(1)
삭제: O(1)

    

<?> 함수 뒤에 오는 const는 어떤 의미인지 알아보기
bool operator==(const FStudentData& InOther) const {
	return Order == InOther.Order;
}




12강. 언리얼 엔진의 메모리 관리 
===========================================================================================================
강의목표
----------------------------------------------------------------------------
언리얼 엔진의 메모리 관리 시스템의 이해
안정적으로 언리얼 오브젝트 포인터를 관리하는 방법의 학습



언리얼 엔진의 자동 메모리 관리 시스템
----------------------------------------------------------------------------
ㅇC++언어의 메모리 관리의 문제점
   -저수준으로 메모리 주소에 직접 접근하여 포인터를 사용해 오브젝트를 관리
   -프로그래머가 직접 new(할당)과 delete(해지) 짝 맞추기를 해야함
   -잘못된 포인터 사용으로 
      .메모리 누수(릭Leak): new를 했는데 delete 짝을 맞추지 못함. 힙 매모리가 그대로 남아있음
      .허상(댕글링Dangling) 포인터: (다른곳에서) 이미 해제해 무효화된 오브젝트의 주소를 가리키는 포인터
      .와일드(Wild) 포인터: 값이 초기화되지 않아 엉뚱한 주소를 가리키는 포인터

ㅇC++이후 나온 언어 Java/C#은 이런 고질적인 문제를 해결하기 위해 포인터를 버리고 대신
  가비지컬렉션 시스템을 도입함 


가비지 컬렉션 시스템
----------------------------------------------------------------------------
-프로그램에서 더 이상 사용하지 않는 오브젝트를 자동으로 감지해 메모리를 회수하는 시스템
-동적으로 생성된 모든 오브젝트 정보를 모아둔 저장소를 사용해 사용되지 않는 메모리를 추적
-마크-스윕 방식을 사용한다


언리얼의 가비지 컬렉션 시스템
----------------------------------------------------------------------------
-자체적으로 마크-스윕 방식을 구축
-Proect Settings / Garbage Collection 에서 세팅 가능
-지정도니 주기마다 몰아서 사용하지 않는 메모리 회수 
-기본 GCCycle은 60초, 프로젝트 세팅에서 변경 가능
-관리되는 모든 언리얼 오브젝트의 정보를 저장하는 전역변수 : GUObjectArray가 존재
-가비지 컬렉터는 GUObjectArray에 있는 플래그 값들을 확인하여 회수 실행 
   .Garbage플래그: 다른 언리얼 오브젝트로부터의 참조가 없어 회수 예정인 오브젝트
   .RootSet플래그: 다른 언리얼 오브제트로부터의 참조가 없어도 회수 하지 않는 특별한 오브젝트
-AddToRoot()함수를 호출해서 루트셋 플래그를 설정하면 최초 탐색 목록으로 설정되어 메모리 회수로부터 제외된다.
   .RemoveFromRoot()함수로 플래그 제거 가능

언리얼에서의 주의 사항 
----------------------------------------------------------------------------
-생성한 오브젝트는 C++의 delete 명령으로 제거하는게 아닌 
 래퍼런스 정보를 없앰으로써 언리얼의 가비지 컬렉터가 자동으로 메모리를 회수하도록 설정해야함 


언리얼 오브젝트를 통한 포인터 문제의 해결
----------------------------------------------------------------------------
-메모리 누수(릭Leak): new를 했는데 delete 짝을 맞추지 못함. 힙 매모리가 그대로 남아있음
   .언리얼 오브젝트: 가비지컬렉터가 자동으로 해결
   .C++오브젝트: 직접 신경써야 한다.(스마트 포인터 라이브러리를 활용)

-허상(댕글링Dangling) 포인터: (다른곳에서) 이미 해제해 무효화된 오브젝트의 주소를 가리키는 포인터
   .언리얼 오브젝트: IsValid()함수 제공
   .C++오브젝트: 직접 신경써야 한다.(스마트 포인터 라이브러리를 활용)

-와일드(Wild) 포인터: 값이 초기화되지 않아 엉뚱한 주소를 가리키는 포인터
   .언리얼 오브젝트: UPROPERTY 속성을 지정하면 자동으로 nullptr로 초기화 해줌
   .C++ 오브젝트: 포인터는 직접 nullptr로 초기화할 것 (또는 스마트 포인터 라이브러리 활용)



회수되지 않은 언리얼 오브젝트
----------------------------------------------------------------------------
언리얼 엔진이 회수에서 제외하는 경우

언리얼 엔진 방식으로 참조를 설정한 언리얼 오브젝트
   -UPROPERTY로 참조된 언리얼 오브젝트
   -AddReferencedObject()함수를 통해 참조를 설정한 언리얼 오브젝트

루트셋으로(RootSet)으로 지정된 언리얼 오브젝트

UPROPERTY를 사용하지 못하는 환경이라 직접 언리얼 오브젝트를 관리해야 하는 경우
   - 일반 C++객체의 멤버변수로 들어가는 형태
   - 이때는 FGCObject클래스를 상속받은 후 AddReserencedObjects()함수를 구현해줘야 한다 

언리얼 오브젝트의 관리 원칙 
----------------------------------------------------------------------------
생성된 언리얼 오브젝트를 유지하기 위해 레퍼런스 참조 방법을 설계할 것
   -언리얼 오브젝트 내의 언리얼 오브젝트: UPROPERTY
   -C++ 오브젝트 내의 언리얼 오브젝트: FGCObject의 상속후 구현

생성된 언리얼 오브젝트를 강제로 지우려 하지 말것
   -참조를 끊는다는 생각으로 구현
   -가비지 컬렉터에게 회수를 재촉할 수는 있음 (ForceGarbageCollection() 함수)
   -콘텐츠 제작에서 Destory()함수를 사용할 수 있으나, Destory() 내부 동작은 동일하다. (가비지컬렉터에게 위임)



언리얼 C++ 프로그래밍 팁
nullptr체크만으로는 해당 언리얼 오브젝트가 유효한지 안유효한지 확인할수 없음
   - nullptr만으로 체크하면 댕글링 포인터 문제를 체크할수 없다


일반 C++ 클래스를 생성은 None으로 진행 / 클래스 이름 앞에 점미사 F를 수동으로 붙여줘야 한다.
   - 일반객체 포인터의 경우, nullptr로 항상 초기화 해주기 



<?> GetReferencerName은 왜 override 한거지?  F로 접두사를 임의로 붙여줘서 그런가?






13강.언리얼 오브젝트 관리1 - 직렬화
===========================================================================================================
강의 목표
----------------------------------------------------------------------------

직렬화란?
----------------------------------------------------------------------------

언리얼 엔진의 직렬화 시스템 
----------------------------------------------------------------------------

실습
----------------------------------------------------------------------------

JSON 직렬화
----------------------------------------------------------------------------
JSON
   -JavaScript Object Notation

JSON을 언리얼에서 사용하기 위해선... 



Json 데이터 예시 스킵 





언리어 스마트 포인터 라이브러리 
----------------------------------------------------------------------------
-일반 C++ 오브젝트의 포인터 문제를 해겨랳주는 언리얼 엔진의 라이브러리 

-TUniquePtr 유니크 포인터 : 지정한 곳에서만 메모리를 관리하는 포인터
   . 특정 오브젝트에게 명확하게 포인터 해지 권한을 주고 싶은 경우
   . delete 구문 없이 함수 실행 후 자동으로 소멸시키고 싶을 때

-TSharedPtr공유 포인터

-TSharedRef 공유레퍼런스 




<!> 언리얼에서 JSON라이브러리를 사용할땐, 
   헤더 선언과 동시에 UnrealSerializationBuild.cs에 구현부도 세팅해 줘야 한다 
   그렇지 않으면 빌드 실패 



정리 
----------------------------------------------------------------------------
이번 강의는 복잡하니 적어놓자 







14강.언리얼 오브젝트 관리2 - 패키지
===========================================================================================================
강의 목표
----------------------------------------------------------------------------
언리얼 엔진의 애셋과 이를 포장한 패키지의 개념 이해
언리얼 에디터에서 볼 수 있도록 애셋을 저장하고 불러들이는 방법의 이해
오브젝트 패스를 사용해 다양한 방식으로 애셋을 로딩하는 방법의 이해 


언리얼 오브젝트 패키지
----------------------------------------------------------------------------
언리얼 엔진은 패키지 단위로 언리얼 오브젝트를 관리 

패키징의 중의적 개념 



패키지와 애셋
----------------------------------------------------------------------------
기본적으로 언리얼 오브젝트들은 기본 패키지인 Transient Package에 포함되어 있다.

애샛 : 언리얼 오브젝트 패키지의 서브 오브젝트, 에디터에는 이들이 노출됨
애셋의 서브 오브젝트 : 



애셋 참조와 로딩
----------------------------------------------------------------------------
ㅇ애셋 정보의 저장과 로딩 전략 


ㅇ오브젝트 경로 
-{애셋클래스정보}'{패키지이름}.{애셋이름}' 또는 {패키지이름}.{애셋이름}
-애셋클래스정보는 생략가능 
-애셋클래스정보륿 붙일때는 ''까지 해줘야 한다.


ㅇ공식 문서 URL: 
강참조, 약참조 

각종 참조 방식 


애셋 스트리밍 관리자
----------------------------------------------------------------------------
애샛의 비동기 로딩을 지원하는 관리자 객체
콘텐츠 제작과 무관한 싱글턴 클래스에 FStreamableManager를 선언해두면 좋음
   - GameInstance는 좋은 선택지
....


실습
----------------------------------------------------------------------------



//14강. 패키지와 애샛 생성 및 저장

//저장한 패키지 로드

//생성자에서 애셋 로드 - 게임 시작전 로드되어 있어야하는 경우

//14강. 비동기 애셋 로드





<!> 생성자에서 에셋을 로드하는 경우, 해당 애셋이 반드시 있어 로드가 성공한다는 전제가 깔림
   그렇지 않으면 에디터 시작시 에러 팝업이 출력됨.


<?> 유니티에서는 비동기로 에셋을 로드하지 않는듯 한데.. 왜그러지 
   언리얼은 비동기 로드가 일반적인건가?




15강.언리얼 빌드 시스템    (복습 스킵, 바로 복습할 필요는 없을듯 하다)
===========================================================================================================
강의 목표
----------------------------------------------------------------------------
언리얼 엔진의 프로젝트 구성과 에디터 동작 방식의 이해 
언리얼 엔진의 모듈 시스템을 기반으로 소스코드를 구성하는 방법의 학습 
언리얼 플러그인 시스템을 활용한 효과적인 묘듈구성의 학습 


언리얼 에디터 구성
----------------------------------------------------------------------------
스킵 


언리얼 에디터의 동작
----------------------------------------------------------------------------
ㅇ에디터 실행 방식


에디터 버전 정보의 파악 
----------------------------------------------------------------------------
ㅇ각 폴더의 용도 
-Config
-Content
-DerivedDataCache
-Intermediate
   .삭제해도 실행시 자동 복구된다. 
-Saved


ㅇ블루푸린트 프로젝트
   -C++코드가 없는 언리얼 프로젝트를 의미

ㅇ언리얼 C++프로젝트
   - 

언리얼 C++모듈
------------------------------------------
----------------------------------
소스코드는 모두 모듈 단위로 구성되어 있음


ㅇ언리얼 C++모듈의 추가 


모듈 C++코드의 관리 
----------------------------------------------------------------------------

Source폴더의 구조 
----------------------------------------------------------------------------
언리얼 빌드는 C#으로 설계되어 있음 


게임 프로젝트의 소스
----------------------------------------------------------------------------


플러그인 시스템 
----------------------------------------------------------------------------
ㅇ플러그인 구조 

ㅇ












































=================================================================================================================================================
Part2
=================================================================================================================================================


1강. 언리얼 엔진 게임 제작 기초 
===========================================================================================================

강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소 
   - 게임/모드 AABGameMode 
   - 플레이어 AABPlayerController
   - 폰 AABCharacterBase/AABCharacterPlayer

1.프로젝트 생성
   - C++ Blank 탬플릿
   - BLUEPRINT / C++ 중에 C++ 선택

2.맵 생성 및 요소들 배치

3.GameMode 생성 / 프레임웍 요소들 클래스 생성 및 GameMode에 적용
   ★ ArenaBattleBuild.cs에 디렉토리를 지정해줘야 해당 폴더에 생성이 가능하다
         PublicIncludePaths.AddRange(new string[] { "ArenaBattle" });
   - DefaultPawnClass, PlayerControllerClass 세팅
         PlayerControllerClass = AABPlayerController::StaticClass();
   - 세팅이 적용된건 WorldSetting에서 확인
      . Outliner 창 최상단 (Step2) 우클릭 / World Settings
      . World Settings / Selected GameMode

4.ThirdPerson 컨텐츠 팩 추가 
   - Content Browser / Add / Add Feature or Content Pack / Third Person

5.게임 시작시, 마우스 커서를 뷰포트 안으로
   - ABPlayerController.BeginPlay()
         FInputModeGameOnly GameOnlyInputMode;
	      SetInputMode(GameOnlyInputMode);
   - 이 때, Shift+F1키를 사용해 뷰포트에서 마우스 커서를 뺄 수 있다.

6.ConstructorHelpers::FClassFinder을 이용해 클래스 정보를
  ConstructorHelpers::FObjectFinder을 이용해 애셋 정보를 가져올 수 있다.
   - Cotent창에서의 우클릭-Copy Reference를 이용하면 생성한 cpp파일의 헤더를 include해주지 않아도 클래스정보를 가져올 수 있다. 
   - 헤더파일을 include하면 해당 소스파일 전체에 의존성이 생기지만, 변수로 가져올시 변수 접근범위로 의존성을 줄일수 있다.
         static ConstructorHelpers::FObjectFinder<USkeletalMesh> CharacterMeshRef(
            TEXT("/Script/Engine.SkeletalMesh'/Game/InfinityBladeWarriors/Character/CompleteCharacters/SK_CharM_Cardboard.SK_CharM_Cardboard'"));

         static ConstructorHelpers::FClassFinder<UAnimInstance> AnimInstanceClassRef(TEXT("/Game/ArenaBattle/Animation/ABP_ABCharacter.ABP_ABCharacter_C"));
         


게임 프레임 웍의 요소들 설명
----------------------------------------------------------------------------
ㅇ게임 프레임 웍의 요소들
   게임 - 월드 / 모드 / 상태
   기믹 - 트리거 / 스폰/ 물리
   플레이어 - 입력 / 카메라 / HUD / 상태
   폰 - 이동 / 모션 / 액션 / 위젯
   데이터 - 애셋 / 테이블 / 설정 / 저장
   인공지능 - 길찾기 / BT

ㅇ게임모드는 하나의 게임에 하나만 존재
ㅇ액터는 접두사 A
ㅇ플레이어는 무형의 액터, 월드에 배치된 폰에 빙의해서 조종하는 개념



프로젝트 소스코드 폴더 규칙
----------------------------------------------------------------------------
ㅇ폴더마다 다른 폴더와의 의존성을 최소화 (다른 폴더의 헤더 참조를 최소화)

ㅇ 폴더 네이밍, 역할
   Game: 게임 모드와 게임 설정 관련 클래스 
   Gimmick: 기믹 배경 물체 관련 클래스
   Player: 플레이어 관련 클래스
   Input: 플레이어 입력 관련 크랠스
   Character: 기본 캐릭터와 PC 및 NPC 관련 클래스
   Acition: 캐릭터 액션 관련 클래스
   Item: 캐릭터 아이템 관련 클래스
   Stat: 캐릭터 스탯 관련 클래스
   AI: NPC 인공지능에 관련 클래스
   UI: UI 관련 클래스 
   Physisc: 물리 충돌체 설정 관련 전처리기 
   Interface: 인터페이스 클래스



클래스 생성 규칙 
----------------------------------------------------------------------------
ㅇ모든 클래스는 AB(ArenaBattle의 약자)의 접두사로 시작 
ㅇ폴더마다 다른 폴더와의 의존성을 최소화
   - 가급적 다른 폴더의 헤더를 직접 참조하지 않도록 구성하는게 바람직하다.
   - 다른 폴더의 클래스에 접근할 때 가급적 인터페이스를 통해 접근
ㅇ헤더 경로를 찾기 쉽도록 모듈.Build.cs파일에 모듈의 폴더를 인크루드 경로에 설정 

<?> 다음과 같은 규칙: 



언리얼 C++ 
----------------------------------------------------------------------------
ㅇConstructorHelpers  
   - ConstructorHelpers::FClassFinder을 이용해 클래스 정보를
   - ConstructorHelpers::FObjectFinder을 이용해 애셋 정보를 가져올 수 있다.
   - Cotent창에서의 우클릭-Copy Reference를 이용하면 생성한 cpp파일의 헤더를 include해주지 않아도 클래스정보를 가져올 수 있다. 
   - 헤더파일을 include하면 해당 소스파일 전체에 의존성이 생기지만, 변수로 가져올시 변수 접근범위로 의존성을 줄일수 있다.
   - 클래스를 가져올 때는 ''를 제거하고 맨 뒤에 _C를 붙여줘야한다.
         static ConstructorHelpers::FObjectFinder<USkeletalMesh> CharacterMeshRef(
            TEXT("/Script/Engine.SkeletalMesh'/Game/InfinityBladeWarriors/Character/CompleteCharacters/SK_CharM_Cardboard.SK_CharM_Cardboard'"));

         static ConstructorHelpers::FClassFinder<UAnimInstance> AnimInstanceClassRef(TEXT("/Game/ArenaBattle/Animation/ABP_ABCharacter.ABP_ABCharacter_C"));
         
ㅇ StaticClass 
   - C++로 작성된 클래스의 정적 인스턴스를 얻기 위해 사용
      .클래스의 메타데이터에 접근하거나, 특정 클래스 타입의 인스턴스 없이 클래스 자체를 참조
   - AABPlayerController::StaticClass();
   - 대체방식: ConstructorHelpers::FClassFinder
    	static ConstructorHelpers::FClassFinder<APlayerController> PlayerControllerClassRef(TEXT("/Script/ArenaBattle.ABPlayerController"));
   - 왜 대체하는지 : 헤더를 include하지 않아 의존성 제거, 애셋을 가져오는것처럼 경로로 접근
   - 차이점: StaticClass는 헤더에서도 사용 가능, ConstructorHelpers::FClassFinder는 생성자에서 다뤄야 한다. 
   - StaticClass 함수를 통해 얻어지는 것은 실제 클래스의 인스턴스가 아니라 클래스 자체의 메타데이터를 참조하기 위한 포인터

※ 정적 인스턴스
   - 일반적으로 객체 지향 프로그래밍에서 사용되는 용어와는 약간 다른 맥락에서 언리얼 엔진 내부에서 사용
   - 언리얼 엔진 내에서, 특정 클래스의 "정적" 인스턴스라 함은, 그 클래스 타입의 싱글톤 인스턴스를 의미하기도 하고,
      단순히 정적 메소드나 프로퍼티에 접근하기 위한 수단을 의미하기도 합니다. 


ㅇ헤더 경로를 찾기 쉽도록 모듈.Build.cs 파일에 모듈의 폴더를 인크루드 경로에 설정
   - PublicIncludePaths.AddRange(new string[] {"모듈이름"}); 
     (예제의 경우,  PublicIncludePaths.AddRange(new string[] { "ArenaBattle" });
   - 헤더를 추가할 때, 경로에서 ArenaBattle을 생략 가능해진다. 
      #include "Animation/AnimMontage.h"









2강. 캐릭터와 입력 시스템 
===========================================================================================================

강의목표
----------------------------------------------------------------------------
액터와 컴포넌트 개념의 이해
블루프린트로 확장 가능한 프로퍼티 설계
언리얼 엔진의 폰과 캐릭터 시스템의 이해 
언리얼 엔진5이 제공하는 향상된 입력 시스템의 활용 

강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   - 플레이어/입력
   - 폰에대한 기초적인 내용


1. 블루프린트를 이용한 배경 사물 액터 생성하기

2. C++을 사용해 배경 사물 액터 생성하기
   - 컴포넌트 생성
   - 생성한 컴포넌트 루트 지정 및 계층구조 설정
   - 컴포넌트에 스태틱메쉬 지정(생성자에선 ContructorHelpers로 에셋 참조)
   
3.C++로 만든 액터는 블루프린트의 Class Setting을 통해 액터 생성 가능
   - 액터의 기반은 C++로 만들어두고, 블루프린트로 확장하는것이 효과적인 제작방식
   - 블루프린트 창 / Details창 / Class Options / Parent Class를 생성한 클래스로 변경

4. 캐릭터 생성
   - 기존 ThirdPerson을 제외 / 생성한 폰(ABCharacterBase)을 상속받는 ABCharacterPlayer로 세팅

5. 카메라 컴포넌트 추가 및 세팅
 	//Meta = (AllowPrivateAccess = "true"): private로 선언된 언리얼 오브젝트를 블루프린트에서 접근할수 있게해준다.
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, Meta = (AllowPrivateAccess = "true"));

6. 입력 컴포넌트 추가 및 세팅 
   - AreaBattle.Build.cs의 PublicDependencyModulesNames.에 "EnhancedInput" 추가
   - IA_Move에 Modifiers 추가 
      . Swizzle Input Axis Values YXZ : AD입력(x축 입력)을 Y축(좌우)으로 / WS(Y축 입력)을 X축(앞뒤)으로 사용


액터와 컴포넌트
----------------------------------------------------------------------------
ㅇ액터의 구조
   - 월드에 속한 컨텐츠의 기본 단위
   - 트론스폼을 가지며, 월드로부터 틱과 시간 서비스를 제공 받는다.
   - 액터는 논리적인 개념으로 컴포넌트를 감싼 포장 박스고 실질적인 구현은 컴포넌트가 진행
   - 액터는 다수의 컴포넌트를 가지는데, 대표하는 컴포넌트를 루트 컴포넌트라 한다.
   - 액터는 반드시 루트 컴포넌트를 가지며, 루트컴포넌트의 트랜스폼은 액터의 트론스폼 



C++ 액터에서 컴포넌트의 생성
----------------------------------------------------------------------------
ㅇ컴포넌트는 언리얼 오브젝트이므로 UPROPETY를 설정하고 TObjectPtr를 사용해 포인터 선언해야 한다.

ㅇ컴포넌트의 등록
   - CDO(생성자)에서 생성한 컴포넌트는 자동으로 월드에 등록
   - 런타임 중에, NewObject로 생성한 컴포넌트는 반드시 등록절차 필요 (ResisterComponent)
   
★컴포넌트 지정자: 에디터 편집 및 블루프린트 확장 등의 매크로 
   - 기본으로 사용되는 매크로 
      .Visible: 접두사, 객체 타입인 경우 
      .Edit: 접두사, 값 타입인 경우 
      .AnyWhere / DefaultsOnly / InstanceOnly: 접미사, 에디터에서 편집 가능 영역
      .Transient: 디스크에 저장될 필요가 없는 타입인 경우 (프레임마다 변경되는 값 같은 UI쪽에서 사용하는듯?)
   -> ex. VisibleAnywhere
   -> VisibleInstanceOnly: 각 인스턴스마다 다른 값으로 세팅

   - 옵션
      .BlueprintReadOnly / BlueprintReadWrite: 블루프린트로 확장시 읽기 쓰기 권한 
      .Category: 에디터 편집 영역에서의 카테고리 지정
      .AllowPrivateAccess = "true": private으로 선언된 객체를 블루프린트에서 접근가능하도록


캐릭터 제작 
----------------------------------------------------------------------------
ㅇ폰의 기능과 설계 
   - 폰은 액터를 상속받으며, 추가적으로 플레이어의 입출력 처리 가능, 길찾기 기능 사용 가능
   - 세가지 주요 컴포넌트가 포함된다.
      .충돌 컴포넌트 (루트 컴포넌트)
      .메시 컴포넌트
      .움직임을 담당하는 컴포넌트
   - 액터 컴포넌트: 트랜스폼 컴포넌트 없이 기능만 제공
   - 씬 컴포넌트: 트랜스폼 컴포넌트 포함

ㅇ캐릭터의 기본 구조
   - 인간형 폰
   - 폰의 세가지 주요 컴포넌트가 자동으로 포함되어 있다.
      .캡슐 컴포넌트
      .애니메이션 캐럭터를 표현하는 스켈레탈 메시 컴포넌트
      .캐릭터 무브먼트 컴포넌트


입력 시스템 개요
----------------------------------------------------------------------------
ㅇ입력 시스템의 동작 방식
   -입력은 PlayerController를 통해 Pawn에게 전달 되는 구조로 
    입력을 컨트롤러가 처리할 수도, 폰이 처리할수도 있지만 일반적으로는 폰이 처리하도록 설계한다.
    (ex.자동차를 타거나 비행기를 타거나 입력에 따른 조작이 달라지는 경우 폰이 유연하게 대처 가능)

ㅇ5.1버전부터 추가된 향상된 입력 시스템
   - 기존 시스템은 사용자의 입력 설정 변경에 대처 불가능, 런타임중에도 변경 가능
   - 4단계로 구조 세분화
      .사용자: 입력
      .입력 매핑 컨텍스트: 입력 연결 (런타임 중 설정에 따라 변경가능)
      .액션: 입력값 변조 -> 이벤트 활성화
      .게임로직: 맵핑된 함수








3강. 캐릭터 컨트롤 설정 
===========================================================================================================
강의목표
----------------------------------------------------------------------------
캐릭터 컨트롤을 위한 각종 설정 옵션의 이해
데이터 애셋을 활용한 설정값의 체계적인 관리
입력 매핑 컨텍스트 활용법의 이해


강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   - 플레이어/카메라
   - 폰/이동

1. 캐릭터 입력->조작을 살펴보기 위해 Look함수와 Move함수 내부 확인, ~로 값 관찰

2. 블루프린트로 캐릭터 에셋 생성, 주요 컴포넌트들 세팅 값들 확인

3. 주요 컴포넌트들의 옵션을 한곳에서 다루기 위한 데이터 에셋 생성 [ABCharacterControlData]
   - Miscellaneous/Data Asset

4. 카메라 데이터 에셋 생성, 컨트롤 관리자로 설정 (3인칭 솔더뷰, 3인칭 쿼터뷰)
   - Add C++ Class / PrimaryDataAsset 상속받아 C++ 생성 [ABCharacterControlData]
      <?> 애셋 parent class로 ABCharacterControlData 세팅 안햇나?

   - 생성한 클래스를 상속받는 데이터 애셋 생성 [ABC_Quater / ABC_Shoulder]
      .Miscellaneous/Data Asset
   
5. 숄더뷰(Move, Look), 쿼터뷰(Move) 및 V키로 변경 기능 구현(기본값은 Quater뷰로)
   - Input/Action폴더: ShoulderMove, ShoulderLook, QuaterMove 생성 
      .Input / Input Action
   - Input폴더: 각 Input Mapping Context 생성 (IMC_Shoulder, IMC_Quater) 위의 액션들 맵핑
      .Input / Input Mapping Context
      .각 InputMappingContext의 Mappings에 액션 추가 
   - CharacterControl: ABC_Quater, ABC_Shoulder 각 캐릭터 컨트롤 에셋에 IMC 세팅
      

캐릭터 컨트롤 요소
----------------------------------------------------------------------------
ㅇ일반적으로 5가지 요소를 사용해 설정
   - 컨트롤러
   - 폰
   - 카메라
   - 스프링암
   - 캐릭터 무브먼트

※Desired Rotation: 회전 목표
  Rotation: 현재 회전 값
 

블루프린트 캐릭터
----------------------------------------------------------------------------
폰의 컨트롤 옵션
   - Use Controller Rotation (Pitch / Yaw / Roll): 컨트롤러에 지정된 Contorl Roation값의 해당값에 폰의 Rotation을 동기화 시킬것인가 

스프링암의 컨트롤 옵션
   - Use Pawn Control Rotation: 컨트롤러에 지정된 Contorl Roation값의 해당값에 스프링암의 Rotation을 동기화 시킬것인가
   - Do Collision Test: 카메라와 캐릭터 사이 장애물이 생겼을 때, 장애물 앞으로 카메라를 당길것인가
      .3인칭 카메라에서 주로 사용

카메라 컨트롤 옵션
   - Use Pawn Control Rotation: 컨트롤러에 지정된 Contorl Roation값의 해당값에 카메라의 Rotation을 동기화 시킬것인가
      . 카메라가 스프링암에 달려있다면, 스프링암의 회전을 함께 고려
      . 1인칭 카메라 회전에 주로 사용

캐릭터 무브먼트의 이동옵션
   - Movement Mode: None, Walking, Falling, ....
      . 땅 위에 있으면 일반적으로 Walking 모드
      . 땅 위에 없으면 Falling 모드
      . 이동 기능을 끄고 싶으면 None 모드
   - MaxWalkSpeed: 이동 모드에서의 이동 수치
   - JumpZVelocity: 폴링 모드에서의 점프 수치

캐릭터 무브먼트의 회전 옵션
   - Rotatino Rate: 회전 속도
   - Use Controller Desired Rotation: 컨트롤 회전을 목표 회전으로 삼고 지정한 속도로 돌리기 
   - Orient Rotation To Movement: 캐릭터 이동방향에 회전을 일치시키기 
   - 폰의 회전 옵션과 충돌하지 않게 주의 필요


<!> 이렇게 분산되어 있을 옵션들을, 데이터 에셋을 만들어 한곳에서 관리하는게 일반적이며 효과적이다.


데이터 에셋
----------------------------------------------------------------------------
UDataAsset을 상속받은 언리얼 오브젝트 클래스 
에디터에서 애셋형태로 데이터 관리를 위해 사용된다.
Miscellaneous/Data Asset으로 생성


단축키
----------------------------------------------------------------------------
~ 틸드 키 
   - 언리얼 재생중에 콘솔창을 활성화하여 특정(UPROPERTY로 지정된) 값의 
     로그를 볼 수있다. 
   - DisplayAll PlayerController ControlRotation : PlayerController의 ControlRotation값을 로그로 확인 가능 


★Final★
----------------------------------------------------------------------------
ㅇ이동관련 로직들을 ABCharacterBase와 ABCharacterPlayer에서 분리 
   캐릭터만의 기능이 아닌 공용로직으로 분리 하기 

IA_QuaterMvoe IA_ShoulderLook IA_ShoulderMove
IMC_Quater IMC_Shoulder
ABC_Quater ABC_Shouler 


에러 노트
----------------------------------------------------------------------------
ㅇ 특정 Inlcude에서 빨간 밑줄, 에러가 출력되나 빌드가 되는 경우
   - VS/UE 종료
   - /Binaries폴더와 .sln파일을 삭제하세요.
   - 파일을 마우스 오른쪽 버튼으로 클릭 .uproject하고 VS 프로젝트 파일을        
     생성합니다.  (혹인 언리얼 Tools/~~~C++ 클릭)
   - VS를 재부팅하면 작동합니다.







4강. 캐릭터 애니메이션 설정 
===========================================================================================================
강의목표
----------------------------------------------------------------------------
캐릭터의 애니메이션 시스템을 생성하는 방법의 학습
캐릭터의 애니메이션 시스템을 효과적으로 설계하는 방법의 학습


강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   - 폰/모션


ㅇ목차
1.C++로 AnimInstance 클래스 생성 및 세팅, 애니메이션 블루프린트 애셋 생성 [ABAnimInstance]
   - 다운받은 스켈레탈 메쉬, 생성한 AnimInstance에셋 ABCharacterBas에서 불러오기
   - 애니메이션 블루프린트가 생성한 C++클래스를 상속 , 기본 로직 구현
   - Animation / Animation Blueprint (parent class를 [ABAnimInstance]로 지정) [ABP_ABCharacter]

2.Anim Graph를 사용하여 애니메이션 시스템 설계
   -  로코모션 구현
    . [ABP_ABCharacter]
    . Legacy/Blend Space 1D 애셋 생성, 이동속도에 따른 이동모션 블렌딩
    . Anim Graph에 생성한 Blend Space애셋 추가
    . CachePoses / New Save Cached...생성, LocoMotion 결과를 저장
    . CachePoses / Use Cached... 생성, 캐싱한 값을 MainStateMachine로, 최종 결과물에 전달
    . State의 priority(클수록 우선순위가 낮음)로 state간 우선순위를 지정할 수 있다

   - Anim Graph를 사용하여 점프 구현

3. ThirdPerson탬플릿의 불필요한 요소들 삭제  




캐릭터 애니메이션 시스템
----------------------------------------------------------------------------
ㅇ스켈레탈 메시 컴포넌트의 애니메이션 블루프린트 클래스를 세팅해두면
   캐릭터가 초기화될 때 AnimInstance클래스의 인스턴스가 생성됨

ㅇ캐릭터와 애니메이션은 상호 참조 관계
   . 캐릭터(ACharacter)는 GetAnimInstance()를 통해 생성된 인스턴스 접근가능
   . 애니메이션 인스턴스(UAnimInstance)는 GetOwningActor함수를 사용해 자신의 소유한 액터 정보 획득 가능


ㅇ애니메이션 블루프린트 구조
   - 이벤트 그래프: GetOwningActor로 캐릭터의 상황을 파악, 주요값들을 AnimInstance 변수에 저장
      . NativeInitializeAnimation: 처음 초기화때 발생하는 이벤트
      . NativeUpdateAnimation: 프레임바다 발생하는 이벤트
   - 애님 그래프: 이벤트 그래프에 저장된 변수를 기반으로 State패턴 동작
      . State Alias로 복잡한 State를 분리해 설계 가능하다.


<?> State Alias: 
   - State패턴을 사용할 때, 참조할수 있는 고급 기법일까?
   - 일단 언리얼에서는, 유니티의 Any와 비슷하지만, 진입 가능 상태를 세팅 가능 
     (유니티에서는 Jump중 Land, Falling중 Land면 각 트랜지션을 연결, 복잡하면 거미줄이 되어버리는 단점을 여기선 극복)
   - 특정 상태일 때만 내부 애니메이션이 동작하도록 체크할수있다(복수 체크 가능)
      <!> 유니티에선 Layer를 나누고 코드로 LayerWeight를 조작하던 기능
 





언리얼 C++ 팁
----------------------------------------------------------------------------
UPROPERTY가 오는 경우 boolean 값을 사용할때, 
보통 uint8 인티저 형을 선언하되 접미사로 b를 붙인 뒤, 비트플래그를 달아준다.
uint8 bIsIdle :1; 




언리얼 팁 
----------------------------------------------------------------------------
AnimBlueprint창에서 MyBluePirnt/기어 아이콘/Show Inherited Variables 을 체크해줘야 
Variables에서 C++변수들이 띄워진다.


Anim Graph 용어
   - state : 
   - state machine
   - transition rule : state이동 조건(화살표) 
   - state alias : state의 상위/ 조건부로 동작할수있도록?
   - Montage / Slot : 생성한 몽타주를 Anim Graph에 적용할때 사용



로코모션
----------------------------------------------------------------------------
캐릭터의 이동과 관련된 애니메이션 시스템
게임 개발 및 3D 애니메이션에서 로코모션은 캐릭터가 환경 내에서 자연스럽게 움직이게 하는 기술을 말합니다. 

이는 걷기, 달리기, 점프하기, 기어가기 등 다양한 이동 방식을 포함할 수 있으며, 
캐릭터의 움직임을 더욱 실감 나고 자연스럽게 만드는 데 중요한 역할을 합니다.

언리얼 엔진에서는 이러한 캐릭터의 움직임을 구현하기 위해 다양한 툴과 시스템을 제공합니다.
예를 들어, 애니메이션 블루프린트, 애니메이션 몽타주, 스켈레탈 메시 등을 사용하여 
복잡한 로코모션 시스템을 만들 수 있습니다. 
또한, 언리얼 엔진은 캐릭터가 지형을 오르내리거나 장애물을 넘는 등의 상호작용을 자연스럽게 처리할 수 있는
다양한 기능을 지원하여, 게임 개발자와 애니메이터가 더욱 생동감 있는 캐릭터 움직임을 구현할 수 있도록 돕습니다.


★Final★
----------------------------------------------------------------------------
ㅇABCharacterBase에서 애니메이션 관련 로직 분리 
   - 수십가지의 캐릭터로 확장할수 있도록 설계하기

ㅇState Alias를 이용해, 로코모션 고도화 하기

ㅇ예제에선 Character쪽에서 행동 함수 하나에서 애니메이션 bool값 조절하지만
  (Jump함수가 호출되면 애니메이션 jump플래그를 true로)
   State 패턴을 적용하여 각 캐릭터 액션 class들에서 다루기 






5강. 캐릭터 콤보 액션 
===========================================================================================================
강의목표
----------------------------------------------------------------------------
애니메이션 몽타주 시스템의 활용 방법
데이터 애셋과 델리게이트를 활용한 콤보 공격의 구현


강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   -폰/액션

1. 애니메이션 몽타주 에셋 생성 및 세팅 [AM_ComboAttack]
   - Animation / Animation Montage 
   - Section 생성, 각 Section 연결 해제

2. 공격시 각 몽타주 Section 진행을 위해, 
    공격 Input액션 추가 및 각 IMC에 세팅 + ABCharacterPlaeyr에 액션 등록 [IA_Attack]

3. CharacterBas에 Combo액션 콜백기능 구현, CharacterPlayer에서 콜백함수 호출시 해당 함수를 호출
   - AnimInstance->Montage_Play(UAnimMontage) 로 재생 가능

4. 캐릭터 플레이어 블루프린트에서 몽타주 세팅, 애님블루프린트에서 몽타주 생성
   - Montage / Slot 'DefaultSlot' 

5. ABGameMode에서 디폴트폰 클래스 변경

6. ABComboAction DataAsset용 클래스 생성, 에셋 생성 후 ABCharacterBase에서 세팅 [ABComboActionData]
   - 몽타주 재생, 종료시 델리게이트 등록
      FOnMontageEnded EndDelegate;
      EndDelegate.BindUObject(this, &AABCharacterBase::ComboActionEnd);
      AnimInstance->Montage_SetEndDelegate(EndDelegate, ComboActionMontage);


7. 타이머 설정, 타이머 내 입력시 다음 몽타주 실행
   - AnimInstance->Montage_JumpToSection()




<!> 블루프린트가 코드 보다 좋은 방법인 경우 
   - FObjectFinder로 참조시, 매번 코드를 변경해야해서 비생산적인 경우 ?? 




언리얼
----------------------------------------------------------------------------
애니메이션 
   - 몽타주의 섹션은 애니메이션 인스턴스에서 조작 가능하다.



언리얼 C++ 
----------------------------------------------------------------------------
UPROPERTY를 붙이는 경우 bool 사용 불가 / int형과 비트플래그로 대체한다. 
 (4강의 uint8 인티저 형을 선언하되 접미사로 b를 붙인 뒤, 비트플래그를 달아준다.)
내부에서만 사용하는 경우 bool 사용 


ㅇ 몽타주 섹션 재생: AnimInstance->Montage_JumpToSection
		UAnimInstance* AnimInstance = GetMesh()->GetAnimInstance();
		
		CurrentCombo = FMath::Clamp(CurrentCombo + 1, 1, ComboActionData->MaxComboCount);

		//재생할 몽타주 Section의 이름 파싱
		FName NextSection = *FString::Printf(TEXT("%s%d"), *ComboActionData->MontageSectionNamePrefix, CurrentCombo);

		//다음 section의 몽타주를 지정하여 재생
		AnimInstance->Montage_JumpToSection(NextSection, ComboActionMontage);


ㅇ 몽타주, 섹션 재생시간 계산 방법
	int32 ComboIndex = CurrentCombo - 1;
	ensure(ComboActionData->EffectiveFrameCount.IsValidIndex(ComboIndex));

	const float AttackSpeedRate = Stat->GetTotalStat().AttackSpeed;
	
	//몽타주 재생 소요시간 계산
	float ComboEffectiveTime = (ComboActionData->EffectiveFrameCount[ComboIndex] / ComboActionData->FrameRate) / AttackSpeedRate;



ㅇ타이머 사용 예시
   - 헤더 
      //5-7: 타이머, 언리얼 엔진 월드의 타이머 기능 활용(FTimerHandle)
      FTimerHandle ComboTimerHandle;
      
   	void SetComboCheckTimer();

   - 소스코드
      //ComboEffectiveTime후 this, &AABCharacterBase::ComboCheck  현재 클래스의 해당 함수 호출, 반복 호출여부는 false
		GetWorld()->GetTimerManager().SetTimer(ComboTimerHandle, this, &AABCharacterBase::ComboCheck, ComboEffectiveTime, false);

   - 람다 사용 예제
   //6-9
	FTimerHandle DeadTimerHandle;
	GetWorld()->GetTimerManager().SetTimer(DeadTimerHandle, FTimerDelegate::CreateLambda(
		[&]()
		{
			Destroy();
		}
	), DeadEventDelayTime, false);




★Final★
----------------------------------------------------------------------------
ㅇ 캐릭터 액션 State를 이와 같이 그래프로 정리하기
![alt text](image.png)


ㅇ 타이머와 Currentcombo, HasNextComboCommand 플래그 등은 캐릭터 Action   State패턴으로 구현하기









6강. 캐릭터 공격판정
===========================================================================================================
강의목표
----------------------------------------------------------------------------
애니메이션 이벤트 발생을 위한 노티파이 설정 방법의 학습
공격 판정을 위한 트레이스 채널 설정과 판정을 시각적으로 디버깅하는 방법의 학습
대미지 프레임웍을 활용한 대미지 전달과 Dead상태의 구현


강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   - 폰/액션

1. 액션판정을 위한 트래이스 채널 생성, 오브젝트 타입에 따른 충돌 프로필 생성
   - Edit/Project Setting/Collision
   - 충돌 프로필 생성 
      . TraceType의 경우 ignore과 block만 신경쓰면 됨
      . ObjectType의 overlap: 길을 막지는 않지만 이벤트 발생 / block: 길을 막음
   - preset / New 눌러서 프로필 생성하기 


2.애니에미션 노티파이에 지정할 프로젝트 전용 노티파이 클래스(AnimNotify 검색) 생성 [AnimNotify_AttackHitCheck]
   - 노티파이: 유니티의 애니메이션 클립(프레임 이벤트) 기능
   - 노타파이 설계시 해당 객체에 직접 접근이 필요해 헤더를 추가하는 경우, 
      객체가 추가될때마다 헤더를 계속 추가해줘야해 유지보숙 어려움, 의존성이 문어발형 식으로 묶인다.
      -> 인터페이스로 관리 [ABAnimationAttackInterface]
   - Montage 편집창에서, Notifies라인에서 우클릭해야 Add Notify가 나옴

3. 탐색기에서 [ABCollison.h] 생성 후 #define 전처리기 작성 / ABCharacterBase에서 사용 및 월드트레이싱 기능 사용
	//식별용 테그, 복잡한 메쉬의 충돌체 감지여부, 무시할 엑터
   FCollisionQueryParams Params(SCENE_QUERY_STAT(Attack), false, this);
	
	FHitResult OutHitResult;
	bool HitDetected = GetWorld()->SweepSingleByChannel(OutHitResult, Start, End, FQuat::Identity, CCHANNEL_ABACTION, FCollisionShape::MakeSphere(AttackRadius), Params);

4. 언리얼 엔진의 디버깅 드로우 기능을 이용해 충돌여부 확인 가능
   #if ENABLE_DRAW_DEBUG
      //센터
      FVector CapsuleOrigin = Start + (End - Start) * 0.5f;

      //둥근부분을 뺀 길이의 절반
      float CapsuleHalfHeight = AttackRange * 0.5f;
      
      FColor DrawColor = HitDetected ? FColor::Green : FColor::Red;

      DrawDebugCapsule(GetWorld(), CapsuleOrigin, CapsuleHalfHeight, AttackRadius, FRotationMatrix::MakeFromZ(GetActorForwardVector()).ToQuat(), DrawColor, false, 0.5f);

   #endif

5. NPC캐릭터 생성, NPC 세팅을 위해 ABCharacterBase에 기본 세팅 추가 [ABCharacterNonPlayer]
   - ABCharacterBase에 애니메이션 몽타주 설정 
   - ABCharacterBase에 스켈레탈 메쉬(NoCollision)와 콜리전프로파일(ABCapsule) 변경 

6. AM_Dead 애니메이션 몽타주 추가, Anim Slot 관리

7. 공격을 받으면 죽도록 기능 구현 
   - 엑터에 구현된 기능 TakeDamage 함수 override 
      . 최종 엑터가 받은 데미지량 return
   -SetDead, PlayDeadAnimation 함수 구현

8. 공격시 데미지[TakeDamage()], 죽는 상태[SetDead()], 죽었을때 애니메이션 재생 함수 생성[PlayDeadAnimation()] 
   - 언리얼 액터에서 제공하는, TakeDamage 함수 overrdie

9. NPC만 죽으면 사라지도록 기능 구현 
   - 월드의 타이머 기능 사용
   - FTimerDelegate를 즉석으로 만들어서 람다 세팅
   FTimerDelegate::CreateLambda(
		[&]()
		{
			Destroy();
		}
	)


충돌 채널의 설정
----------------------------------------------------------------------------
ㅇ 캐릭터 액션의 충돌 판정
   - LineTrace: 유니티의 RayCast같은 방식, 선을 투사
   - Sweep: 선이 아닌 도형을 투사
   - Overlap: 유니티의 collider방식, 지정영역의 범위에 물체


월드 트레이싱 함수의 선택 
----------------------------------------------------------------------------
세가지 카테고리로 원하는 함수의 이름을 얻을 수 있음.
Format: {처리방법}{대상}{처리설정}

카테고리 1: 처리방법 (LineTrace, Sweep, Overlap)
카테고리 2: 대상
   - Test: 무언가 감지 되었는지를 테스트
   - Single 또는 AnyTest: 감지된 단일 물체 정보를 반환
      . LineTrace, Sweep인 경우 Single
      . Overlap인 경우 AnyTest
   - Nulti: 감지된 모든 물체 정보를 배열로 반환 
카테고리 3: 처리설정
   - ByChannel: 채널 정보를 사용해 감지
   - ByObjectType: 물체에 지정된 물리타입 정보를 사용해 감지
   - ByProfile: 프로필 정보를 사용해 감지 

예제: 캐릭터 위치에서 시선방향으로, {작은 구체를 제작해 시선 방향의 특정 거리까지만 투사}
      {하나의 물체}만 {트레이스 채널}을 사용해 감지
   = {Sweep}{Single}{ByChannel}



언리얼 팁 
----------------------------------------------------------------------------
탐색기에서 Source폴더 내부가 변경되었을땐 .uproject 우클릭/Generate Visual Studio... 



   
※ 랙돌(영어: Ragdoll)
----------------------------------------------------------------------------
캐릭터나 객체가 실제 물리 법칙에 따라 자연스럽게 움직이도록 만드는 데 사용됩니다.
랙돌 효과는 주로 캐릭터가 죽거나 큰 충격을 받았을 때 그들의 몸이 마치 실제처럼 힘없이 쓰러지고 늘어지는 것을 모사하기 위해 사용됩니다.

랙돌 시뮬레이션은 캐릭터의 각 부분(예: 팔, 다리, 몸통 등)을 별도의 물리적 객체로 처리하고, 
이들 사이에 물리적 제약 조건(예: 관절)을 설정하여 실제 몸의 움직임처럼 보이게 합니다.
이러한 시뮬레이션은 게임 내에서 더욱 현실적이고 동적인 상호작용을 제공하며, 플레이어에게 몰입감을 높여 줍니다.

언리얼 엔진과 같은 고급 게임 개발 엔진에서는 이러한 랙돌 시뮬레이션을 쉽게 구현할 수 있는 도구와 라이브러리를 제공합니다.
개발자들은 이 기능을 활용하여 물리적 충돌이나 캐릭터의 동작을 더욱 실감나게 표현할 수 있습니다.







7강. 캐릭터 스탯과 위젯
===========================================================================================================
강의목표
----------------------------------------------------------------------------
액터 컴포넌트를 활용한 액터 기능의 확장 방법의 이해 (★액터컴포넌트로 캐릭터가 가진 기능을 분산)
   - <!> MonoBehavior를 상속하지 않은 CastAgent로 분리했던것과 같은 맥락
언리얼 델리게이트를 활용한 발행 구독 모델의 학습
액터의 초기화 단계와 위젯  초기화 과정의 이해 


강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   - 폰/위젯


1. 스탯컴포넌트(ActorComponent 상속) C++ 클래스 생성 [ABCharacterStatComponent]
	//VisibleInstanceOnly: 인스턴스마다 별도의 값을 가지기 때문에 세팅
	UPROPERTY(VisibleInstanceOnly, Category = Stat)
	float MaxHp;

	//Transient: 항상 바뀌는 값이라 디스크에 저장할 필요 없는 경우 세팅
	UPROPERTY(Transient, VisibleInstanceOnly, Category = Stat)
	float CurrentHp;

1-2. [WBP_HpBar] UI위젯 애셋 생성, UserWidget을 상속받은 C++ 클래스 생성 [ABHpBarWidget]  
   - User Interface / Widget Blueprint 
   - UI 애샛생성한 UI컴포넌트 연결
      . UI위잿 에셋 편집창 / 우측상단 Graph / Class Settings/ Parent Class

2. 스탯컴포넌트에 HP변경 시 호출되는 델리게이트 및 콜백함수 생성

3. ABHpBarWidget UI컴포넌트 작업 
   - UI위젯의 생성자는 매개변수가 있음
      . UABHpBarWidget(const FObjectInitializer& ObjectInitializer);
   - 프로그레스 바 기능을 사용하기 위해 헤더 추가
      . #include "Components/ProgressBar.h"
      . 해당 헤더를 사용하기위해 build.cs파일에 "UMG" 모듈을 추가해줘야 한다.
   - UserWidget::NativeConstruct()에서 UserWidget::GetWidgetFromName()을 사용해, 하위 위잿들에 접근
      HpProgressBar = Cast<UProgressBar>(GetWidgetFromName(TEXT("PbHpBar")));

4. 위젯 컴포넌트로 캐릭터에 UI위젯 부착 
	- UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Widget, Meta = (AllowPrivateAccess = "true"))
	  TObjectPtr<class UWidgetComponent> HpBar; 
   - UI위젯이라도 Transform을 가지고 있는 컴포넌트이기 때문에 Attachment 설정을 해줘야 한다
      Weapon->SetupAttachment(GetMesh(), TEXT("hand_rSocket"));

5. UI 클래스들 확장
   - 위젯에 소유한 액터의 정보를 저장 할수 있게 클래스 확장 [UserWidget -> ABUserWidget]
      위젯 컴포넌트 초기화 단계에서 소유한 액터 정보를 설정할수 있게 확장 [WidgetComponent -> ABWidgetComponent]
   - ABHpBarWidget를 UUserWidget가아닌 UABUserWidget을 상속받도록 변경하여, Owner를 저장할수 있게 해준다.

6. 캐릭터와 UI위잿간의 의존성을 제거하기 위해 인터페이스를 생성 [ABCharacterWidgetInterface]
   - 위젯 초기화 단계에서 부모 클래스 정보를 읽고 자신을 등록

<?!> 의존성 제거한다며 결국 ABCharacterBase에서 ABHpBarwidget.h를 include하는디? 
   -> <!> Stat 기능 컴포넌트와 UI위잿 컴포넌트 간의 의존성을 제거
            두 컴포넌트를 가지는ABCharacterBase에서 Stat의 델리게이트를 이용해 중계해준다. 


7. ABCharacterBase에 Stat의 델리게이트 등록, 콜백으로 Dead애니메이션이 재생되도록 변경

8. ABHpBarWidget을 위젯컴포넌트에 연결 



액터 컴포넌트
----------------------------------------------------------------------------
액터 컴포넌트: 액터에 부착할 수 있는 컴포넌트 중 트랜스폼이 없는 컴포넌트

액터의 기능을 컴포넌트로 분리하여 확장할때 사용된다.

예제에선, 스탯 컴포넌트와 UI컴포넌트 사용 



언리얼 델리게이트를 활용한 발행 구독 모델의 구현 
----------------------------------------------------------------------------
푸시 형태의 알림을 구현하는데 적합한 디자인 패턴 

예제에선, 스탯 컴포넌트와 UI컴포넌트 사이의 느슨한 결합을 위해 사용



위젯 컴포넌트와 위젯 
----------------------------------------------------------------------------
위젯 컴포넌트 : 액터 위에 UI위젯을 띄우는 컴포넌트
   - 위젯 컴포넌트는 컨테이너의 역할만할 뿐,  위젯과 액터는 독립되어야 한다


액터의 초기화 과정
----------------------------------------------------------------------------
- 액터의 라이프 싸이클: https://bit.ly/ueactorlifecycle
- 처음부터 씬에 있는 경우와 런타임중 스폰되었을때의 싸이클이 다르다.
   공통적으로 마지막에 모든 초기화가 완료된 타이밍에 호출되는 PostInitializeComponents가 있다. 
   (그 다음이 BeginPlay)
- 액터 초기 세팅은 PostInitializeComoents를, 초기화는 BeginPlay에서 작업 진행 
   BeginPlay때 Tick이 시작됨 (Tick 시작 여부 차이)

   
위잿 컴포넌트의 초기화 과정
----------------------------------------------------------------------------
- WidgetComponent::InitWidget() 인스턴스 생성 -> UUserWidget::NativeConstruct() UI속성 초기화 

- 스탯 컴포넌트는 ACtor::PostInitializeComponents 타이밍에 초기화 완료 
   HpBar UI위젯은 Actor::BeginPlay 이후 생성된다.

- HpBar위젯을 초기화하기위해 위젯 컴포넌트로 부터 스탯 컴포넌트 정보를 얻어와야함 
   but 현재 언리얼에서는 위잿 컴포넌트에서 위젯으로 스탯 컴포넌트 액터 정보를 넘길 수 잇는 방법이 없다.
   따라서 WidgetComponent::InitWidget(인스턴스 생성) / UUserWidget::NativeConstruct (UI 속성 초기화)들을 
   예제에서 확장하여 사용한다
   
- 위젯에 소유한 액터의 정보를 저장 할수 있게 클래스 확장 [UserWidget -> ABUserWidget]
   위젯 컴포넌트 초기화 단계에서 소유한 액터 정보를 설정할수 있게 확장 [WidgetComponent -> ABWidgetComponent]
   위젯 초기화 단계에서 부모 클래스 정보를 읽고 자신을 등록 [ABCharacterWidgetInterface]


언리얼 C++ 
----------------------------------------------------------------------------
ㅇBeginPlay(): 게임이 시작될 때 자동 호출 
// Called when the game starts
void UABCharacterStaComponent::BeginPlay()

ㅇ델리게이트 선언시 /**/ 주석을 사용해 가독성을 높여줄 수 있다.
DECLARE_MULTICAST_DELEGATE_OneParam(FOnHpChangedDelegate, float /*CurrentHp*/);


ㅇ UI컴포넌트 작성시, UI들을 가져오는 경우 NativeConstruct를 사용해 초기화 전의 UI에 접근하지 않게 한다
	//해당 함수가 호출되는 타이밍은 UI관련된 모든 기능들이 거의 초기화 완료 
	virtual void NativeConstruct() override;







8강. 아이템 시스템
===========================================================================================================
강의목표
----------------------------------------------------------------------------
트리거 박스를활용한 아이템 상자의 구현
다양한 종류의 아이템에 대한 개별적인 습득 처리의 구현
소프트오브젝트 레퍼런스와 하드오브젝트 레퍼런스의 차이 이해 


강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   - 기믹/트리거 

1. Actor를 상속받아 [ABItemBox] 생성 및 세팅 / 씬에 아이템상자 배치 

2. [ABItemBox]에 캐릭터에 발동하는 트리거 생성, 트리거 발동시 이펙트 출력
   - 언리얼의 OnComponentBeginOverlap 델리게이트로 충돌시 콜백 등록, 이때 콜백함수는 UFUNCTION()이 붙어있어야한다.
      Trigger->OnComponentBeginOverlap.AddDynamic(this, &AABItemBox::OnOverlapBegin);
   - 언리얼이 제공하는, 이펙트 종료 델리게이트 OnSystemFinished 콜백 함수 등록
      Effect->OnSystemFinished.AddDynamic(this, &AABItemBox::OnEffectFinished);
 
3. ItemDataAsset 클래스 생성 [ABItemData, ABWeaponItemData]
   - [EItemType] Enum 정의

4. 3의 클래스로 세팅된 데이터 에셋 생성, 세팅
   - Miscellaneous / Data Asset / ABItemData [ABIS_ScrollTest, ABIP_PotionTest]
   - Miscellaneous / Data Asset / ABWeaponItemData [ABIW_Weapon1]

5. [ABItemBox]미들웨어에서 [ABCharacterBase]게임레이어로 접근하기위한 인터페이스 생성 [ABCharacterItemInterface]
   - [ABCharacterBase]에서 상속, TakeItem() override 
   - [ABItemBox]의 OnOverlapBegin()에서 충돌한 액터 의 TakeItem() 호출

6. [ABCharacterBase]에서 TakeItem() 구현 
   - swtich문이 아닌 델리게이트로 확장성 고려
      . DECLARE_DELEGATE_OneParam(FOnTakeITemDelegate, class UABItemData* /*InItemData*/);
   - 델리게이트형 배열은 생성 불가, 델리게이트를 관리할 배열을 만들기 위해 구조체 Wrapper 생성 [FTakeItemDelegateWrapper]
      USTRUCT(BlueprintType)
      struct FTakeItemDelegateWrapper {
         GENERATED_BODY()
         FTakeItemDelegateWrapper() {}
         FTakeItemDelegateWrapper(const FOnTakeITemDelegate& InItemDelegate) : ItemDelegate(InItemDelegate) {}
         FOnTakeITemDelegate ItemDelegate;
      };
   - 구조체를 TArray로 관리


   - [ABCharacterBase]에 [FTakeItemDelegateWrapper]배열 생성 및 각 아이템 콜백 생성 및 맵핑

7. 무기상자 획득시, 캐릭터 손에 무기 장착
   - [ABCharacterBase]에 무기를 담을 스켈레탈 메쉬 컴포넌트 추가 및 초기화
   - EquipWeapon()콜백에서 [UABWeaponItemData]의 데이터를 이용해, 캐릭터의 스켈레탈 메쉬 변경 
   - 스켈레탈 메쉬에서 소캣의 위치 조정

8. 게임 시작때부터 메모리에 로드하고 있을 필요 없는 액터의 멤버 언리얼 오브젝트들 소프트 래퍼런싱으로 변경 
   - 게임 시작후, ~틸드키 -> Obj List Class=SkeletalMesh  입력시 로드된 스켈레탈 메쉬들이 로그로 출력된다.
   - ABWeaponItemData
   - 소프트레퍼런싱으로 변경되면서, 이전에 바로 사용하던 부분 변경 [ABCharacterBase.EquipWeapon()]
      TSoftObjectPtr<USkeletalMesh> WeaponMesh;

   	//8-8 소프르레퍼런싱으로 로딩 여부를 확인후 안되었을 경우 로드
		if (WeaponItemData->WeaponMesh.IsPending()) {
			WeaponItemData->WeaponMesh.LoadSynchronous();
		}


의존성 분리를 위한 프로젝트의 주요 레이어 설계
----------------------------------------------------------------------------
아이템이 추가될때마다 클래스와 함수를 만드는 비효울적 개발 방지

게임 레이어: 게임 로직을 구처젝으로 구현하는데 사용 (캐릭터, 게임 모드 등)
미들웨어 레이어: 게임에 사용되는 미들웨어 모듈 (UI, 아이템, 애니메이션, AI 등)
   - 다양한 게임레이어(캐릭터)에 서비스를 공급
데이터 레이어: 기본 게임 데이터 (스탯, 캐릭터 레벨 테이블 등)

위에서 아래는 직접 참조하되, 아래서 위로는 인터페이스를 통해 접근 설정
(게임레이어에서 미들웨어 직접참조 / 미들웨어에서 게임레이어 인터페이스로 접근)



★소프트 레퍼런싱 vs 하드 레퍼런싱
----------------------------------------------------------------------------
TObjectPtr 하드 래퍼런싱
   - 일반적으로 액터에 언리얼 오브젝트 멤버변수를 생성할 때
   - 액터가 로딩 될 때, 언리얼 오브젝트도 따라서 메모리에 로딩된다.  
   - 필수적인 언리얼 오브젝트 로드에 사용 

TSoftObjectPtr 소프트 래퍼런싱
   - 아이템과 같은 언리얼 오브젝트의 경우, 1000개 이상의 아이템이 있는경우 부하 
   - 필요한 데이터만 로딩할 때 사용
   - 선언하고 대신 에셋 주소 문자열을 지정 
   - 해당 멤버 언리얼 오브젝트에 직접접근 불가능, 항상 로드 여부를 체크후 Get()함수로 사용해야한다. 
   		if (WeaponItemData->WeaponMesh.IsPending()) {
			WeaponItemData->WeaponMesh.LoadSynchronous();
		}

		Weapon->SetSkeletalMesh(WeaponItemData->WeaponMesh.Get());

현재 예제에서 ItemBox에서 무기 스켈레탈 메쉬를 하드 래퍼런싱하고 있기 때문에 
캐릭터가 무기를 얻어 장착하기 전부터 메모리에 올라가 있다


<?> 무조건 소프르 레퍼런싱을 적용하는게 좋은건가?
   - 맵에 이미 배치되어있는 요소를 제외하고 ?


언리얼 C++
----------------------------------------------------------------------------
ㅇ언리얼이 지원하는 내부 델리게이트는 블루프린트에서 사용 가능 함으로, 

ㅇ콜백함수를 생성할 때 UFUNCTION()속성을 붙여줘야 한다

ㅇ첫 구조체 정의
   USTRUCT(BlueprintType)
   struct FTakeItemDelegateWrapper {
      GENERATED_BODY()
      FTakeItemDelegateWrapper() {}
      FTakeItemDelegateWrapper(const FOnTakeITemDelegate& InItemDelegate) : ItemDelegate(InItemDelegate) {}
      FOnTakeITemDelegate ItemDelegate;
   };

ㅇ델리게이트 - 등록된 이벤트가 있으면 실행 
		TakeItemActions[(uint8)InItemData->Type].ItemDelegate.ExecuteIfBound(InItemData);






9강. 무한맵의 제작
===========================================================================================================
강의목표
----------------------------------------------------------------------------
무한맵 생성을 위한 기믹 액터의 설계
에셋 매니저를 활용한 애셋 관리 방법의 학습
액터의 스폰과 약참조 포인터의 사용 실습 


강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   - 기믹/스폰
   - 데이터/에셋


1.스테이지에 설치한 트리거 볼륨의 감지 처리
   - Actor를 상속받아 [ABStageGimmick] C++ 클래스 생성

2.각 문에 설치한 네개의 트리거 볼륨의 감지 처리 

3. 블루프린트로 [ABStageGimmic]을 상속받는 애셋 생성
   - 우클릭 / Blueprint Class -> ABStageGimmick 선택 [BP_ABStageGimmick]
   - Step5 맵 생성, 기존 요소들 제거 후 [ABStageGimmick] 배치

4. Stage 상태 enum 생성 [EStageState] 

5. 상태별로 설정한 문(Gate) 설정
   - swtich문으로 구현시, state가 늘어날때마다 점점 복잡해진다.
   - 델리게이트 Wrapper 구조체 생성, 상태와 구조체를 쌍으로 TMap으로 관리 [FStageChangedDelegateWrapper]

6. OnConstruction함수를 이용해, 에디터에서의 값 변경에도 C++클래스가 반응해서 테스트 코드를 따로 만들지 않아도 테스트 가능 
   - [OnConstruction]: 모든 속성의 변경에 호출

7.npc 생성 로직 구현 
   - TSubclassOf: 지정한 클래스로부터 상속받은 클래스들만 한정해서 표시 
     . 블루프린트로 확장시, 상속된 액터들만 나와 편리하다 
   - 런타임 중 스폰
      const FVector SpawnLocation = GetActorLocation() + FVector::UpVector * 88.0f;
      AActor* OpponentActor = GetWorld()->SpawnActor(OpponentClass, &SpawnLocation, &FRotator::ZeroRotator);
      AABCharacterNonPlayer* ABOpponentCharacter = Cast<AABCharacterNonPlayer>(OpponentActor);

8.npc가 죽었을 때 보상, 아이템 박스 스폰
   - ABItemBox의 Trigger 컴포넌트가 protected임으로, 별도 함수 생성
   - 언리얼이 제공하는 Actor.OnDeatoryed 델리게이트에 콜백 연결, 보상 StageState로 변경
   		ABOpponentCharacter->OnDestroyed.AddDynamic(this, &AABStageGimmick::OnOpponentDestroyed);  

9. 게이트 트리거 발동시, 스테이지 생성 
   - 충돌시 StageState상태 FIGHT로 변경
      //충돌 검사 Param - InIgnoreActor: 자신을 충돌검사에 포함시킬지
      FCollisionQueryParams CollisionQueryParam(SCENE_QUERY_STAT(GateTrigger), false, this);
      //충돌 검사
      bool bResult = GetWorld()->OverlapMultiByObjectType(
         OverlapResults,
         NewLocation,
         FQuat::Identity,
         FCollisionObjectQueryParams::InitType::AllStaticObjects,	//모든 static오브젝트에 대해 검사
         FCollisionShape::MakeSphere(775.0f),	//구를 만들어서 검사
         CollisionQueryParam
      );
   - 월드의 타임매니저 기능을 이용해, (7)에서 만들어둔 NPC스폰 함수 호출 
   	GetWorld()->GetTimerManager().SetTimer(OpponentTimerHandle, this, &AABStageGimmick::OnOpponentSpawn, OpponentSpawnTime, false);

<!> String Parsing으로 로직을 굴리는건 
    협업에서는 위험부담이 너무 큼. (아트쪽이 리소스 이름 변경했다고 로직 오류 뜨면 x)

<?> 유니티의 코루틴을 언리얼에서는 월드의 타임매니저를 이용해서 구현하는걸까?  (유니티의 Invoke 대체지, 코루틴과 견줄건 아닌거 같은데)

10.보상 아이템들 식별자 지정 
   - 약참조로 상자 관리
      //TWeakObjectPtr 탬플릿 클래스 사용하여 약참조
      //   - ABStageGimmick에서 관리하지만 AABItemBox 스스로 로직(라이프사이클)이 굴러감
      //   - ABStageGimmick에서가 아닌 외부나 AABItemBox 내부에서 소멸 될 수있음
      //   - 강참조시, 소멸되어도 메모리가 붙잡고 있게된다.
      UPROPERTY(VisibleAnywhere, Category = Reward, Meta = (AllowPrivateAccess = "true"))
      TArray<TWeakObjectPtr<class AABItemBox>> RewardBoxes;
   - 애셋 매니저를 통해, ABItemData 데이터 애셋을 부모로 가지는 애셋들을 전부 가져올수 있게 세팅
      .Project Settings / Asset Manager 
         Primary Asset Type to Scan / + -> ABItemData 추가
         Directories / + -> /Game/ArenaBattle/Item 선택
   - ABItemData, ABWeaponItemDAta에 [GetPrimaryAssetId()]를 오버라이드해서 추가한 PrimaryAssetType로 지정해준다.
      FPrimaryAssetId GetPrimaryAssetId() const override
      {
         return FPrimaryAssetId("ABItemData", GetFName());
      }

11. 상자 랜덤 보상 
   - 액터의 세팅이 마무리되는 시점에 호출되는 [PostInitializeComponents()]사용 
   - FMath::RandRange(0, Assets.Num()-1); //언리얼의 랜덤 방식
   - 애셋 매니저에서 식별키로 애셋들을 가져오는 부분
      UAssetManager& Manager = UAssetManager::Get();
	   TArray<FPrimaryAssetId> Assets;
	   Manager.GetPrimaryAssetIdList(TEXT("ABItemData"), Assets);
	


대전할 NPC의 스폰 기능
아이템 상자의 스폰 기능
다음 스테이지의 스폰 기능 
NPC의 죽음 감지 기능 
아이템 상자의 오버랩 감지 



에셋 매니저
----------------------------------------------------------------------------
언리얼 엔진이 제공하는 에셋 관리 싱글톤 클래스(단 하나의 인스턴스만 존재)로 엔진이 초기화될 때 제공된다.
PrimaryAssetId(태그와 이름 키 조합)를 사용해, 
특정 태그를 가진 모든 애셋 목록을 가져올 수있다.


약참조 vs 강참조 
----------------------------------------------------------------------------
TObjectPtr
   - 강참조
   - 실제 오브젝트가 삭제되어도, 강참조중이라 메모리에서 해제되지 않는다
   - 액터가 소멸될 때 같이 소멸되야하는 하위 액터들은 강참조

TWeakObjectPtr
   - 약참조
   - 참조하는 액터와 무관하게 동작(라이프사이클)인 액터는 약참조
   - 단, 실제로 존재하는 오브젝트인지 확신할수 없다. 사용전 반드시 IsValid()가 동반되야 한다


언리얼 팁 
----------------------------------------------------------------------------
ㅇ블루프린트
  - TSubclassOf: 지정한 클래스로부터 상속받은 클래스들만 한정해서 표시 
     . 블루프린트로 확장시, 상속된 액터들만 나와 편리하다 
      UPROPERTY(EditAnywhere, Category = Fight, Meta = (AllowPrivateAccess = "true"))
      TSubclassOf<class AABCharacterNonPlayer> OpponentClass;

ㅇ애셋매니저
   - 애셋 매니저를 통해, ABItemData 데이터 애셋을 부모로 가지는 애셋들을 전부 가져올수 있게 세팅
      .Project Settings / Asset Manager 
         Primary Asset Type to Scan / + -> ABItemData 추가
         Directories / + -> /Game/ArenaBattle/Item 선택
   - ABItemData, ABWeaponItemDAta에 [GetPrimaryAssetId()]를 오버라이드해서 추가한 PrimaryAssetType로 지정해준다.
      FPrimaryAssetId GetPrimaryAssetId() const override
      {
         return FPrimaryAssetId("ABItemData", GetFName());
      }

   - 애셋매니저는 엔진이 초기화 될 때 로딩이 보장됨으로, static함수인 Get()사용 
	   UAssetManager& Manager = UAssetManager::Get();
   - GetPrimaryAssetIdList
      UAssetManager& Manager = UAssetManager::Get();
	   TArray<FPrimaryAssetId> Assets;
	   Manager.GetPrimaryAssetIdList(TEXT("ABItemData"), Assets);
	

언리얼 C++ 
---------------------------------------------------------------------------- 
ㅇ충돌검사
	//충돌 검사 Param - InIgnoreActor: 자신을 충돌검사에 포함시킬지
	FCollisionQueryParams CollisionQueryParam(SCENE_QUERY_STAT(GateTrigger), false, this);
	//충돌 검사
	bool bResult = GetWorld()->OverlapMultiByObjectType(
		OverlapResults,
		NewLocation,
		FQuat::Identity,
		FCollisionObjectQueryParams::InitType::AllStaticObjects,	//모든 static오브젝트에 대해 검사
		FCollisionShape::MakeSphere(775.0f),	//구를 만들어서 검사
		CollisionQueryParam
	);


Final
----------------------------------------------------------------------------
아이템 과 NPC, 오브젝트 풀링 
아아템 바닥에 드랍 






10강. 게임데이터 관리
===========================================================================================================
강의목표
----------------------------------------------------------------------------
게임 데이터를 관리하는 싱글톤 객체의 등록 
엑셀 데이터 및 INI파일을 활용한 게임 데이터의 관리
액터의 초기화를 위한 지연 생성 기능의 이해와 활용


강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   - 데이터/테이블, 데이터/설정

1. 게임 데이터가 기록된 엑셀 .xlxs 파일을 .csv파일로 변환 

2. 동일한 컬럼 이름을 멤버 변수로 가지는 구조체헤더 생성 [ABCharacterStat.h]
   - FTableRowBase를 상속
 
3~5. 아래의 "CSV 파일 로드 및 적용" 참고

6.[ABCharacterStatComponent]에 [ABCharacterStat] 변수 추가
   - 기존 임시 스탯 코드들 일괄 변경   
 
7.기믹[ABStageGimmick]에도 스택 적용, 다음 스테이지를 생설할때마다 증가, NPC레벨 반영
   - [ABCharacterBase.GetLevel() / SetLevel()]
   
8.기믹, NPC, 상자 생성에 지연 생성 적용, [SpawnActorDeferred]
   - 상자스폰에 지연생성을 적용하기 전에 
      ABItemBox의 생성자에서 OnComponentBeginOverlap에 OnOverlapBegin콜백 함수를 바인딩하던 부분을 
      PostInitializeComponents로 이전
   ※PostInitializeComponents는 BeginPlay 이후에 호출됨

<?> StaticClass()
   AABStageGimmick* NewGimmick = GetWorld()->SpawnActorDeferred<AABStageGimmick>(AABStageGimmick::StaticClass(), NewTransform);

9. 무기에 스탯 데이터 적용, 캐릭터가 무기를 장착하면 스탯 획득

10.NPC 스폰시 스켈레탈 매쉬가 다르게 생성되도록 변경
   - Config / DefaultArenaBattle.ini 파일 비동기 로드
      . ABCharacterNonPlayer.NPCMeshes 변수에 스켈레탈 메쉬 애셋들 저장 / "+"는 배열을 의미 
   - UCLASS(config=ArenaBattle): 해당 클래스가 DefaultArenaBattle.ini 파일을 로드하겠다는것을 의미
   - UPROPERTY(config): config를 통해 데이터를 불러오겠다는 의미
   - 변수명은 ini에 지정한 변수이름과 동일해야한다. [NPCMeshes]
   - 비동기 로드
      . [헤더] #include "Engine/StreamableManager.h"	//10-10 비동기 로드
      . [헤더] TSharedPtr<FStreamableHandle> NPCMeshHandle;   //비동기 로드를 위한 구조체 선언
      . [소스파일] #include "Engine/StreamableManager.h"	//10-10 비동기 로드
      . [소스파일] NPCMeshHandle = UAssetManager::Get().GetStreamableManager().RequestAsyncLoad(NPCMeshes[RandIndex], 
                     FStreamableDelegate::CreateUObject(this, &AABCharacterNonPlayer::NPCMeshLoadCompleted));
                     //비동기 로드가 종료되면 NPCMeshLoadCompleted 호출
      . [소스파일] NPCMeshHandle->ReleaseHandle();   //비동기 로드가 완료되었으니, 핸들 해제



CSV 파일 로드 및 적용
----------------------------------------------------------------------------
0.DataAsset과 유사하게 FTableRowBase를 상속받은 구조체를 선언 

0.엑셀의 Name컬럼을 제외한 컬럼과 동일하게 UPROPERTY속성을 선언 
   - 엑셀의 데이터 시트에는 Name 컬럼이 반드시 들어가야한다. (key)

0.엑셀데이터를 csv로 익스포트 후 언리얼 엔진에 임포트

4.데이터 테이블 에셋 생성 [ABCharacterStatTable]
   - Miscellaneous/Data Table
   - 에셋 편집들어가서 Reimport
   - csv 파일 선택 

5.데이터 테이블 에셋 관리 클래스 생성 
   - 데이터 관리 클래스는 보통 게임내 단 한개만 존재함으로, 싱글톤 적용
   - 언리얼에서의 싱글톤 적용 
      . Project Setting/Engine/General Settings/Default Classes/Advanced/Game Singleton Class 에 추가
      . 프로젝트 재시작해야 적용됨
   - None (Unreal Object)형의 C++ 클래스 생성 [ABGagmeSingleton]
   - 어디서든 접근할 수 있게, static Get함수 생성 (로드가 보장됨으로) 
   - GEngine->GameSingleton //GEngine 전역변수를 통해 Proejct Settings에서 세팅한 싱글톤 참조 가능
   - //CastChecked로 형변환이 되는지 (가져온게 유효한 객체인지) 강력하게 확인
      UABGameSingleton* Singleton = CastChecked<UABGameSingleton>(GEngine->GameSingleton);
※ 엑셀에서 데이터가 수정된경우, csv를 재 export 한 후 / Reimport를 눌러주면 된다.
   - CSV애셋을 FObjectFinder로 가져와, <key, value>쌍중 value만 뽑아서 TArray에 저장 (레벨 데이터임으로 순차적 접근하면 됨, 키가 필요없음)



액터의 생성과 지연 생성 프로세스 
----------------------------------------------------------------------------
SpawnActor(): BeginPlay -> 초기화
SpawnActorDeferred(): 초기화 -> FinishSpawning -> BeginPlay
   - 생성자에서 세팅된 값이 아닌 초기화값을 BeginPlay에서 다룬다면 지연생성 사용하기 


지연생성
----------------------------------------------------------------------------
NPC 레벨과 스탯이 2레벨로 적용(Hp 150)되었지만, CurrentHp는 100 그대로인 문제
   - NPC SpawnActor() 호출시, 바로 ABCharacterStatComponent.BeginPlay()가 호출
   - ABCharacterStatComponent.BeginPlay()에서 SetHP() 호출
   - SpawnActor이후, 해당 액터를 캐스팅하여 SetLevel()호출 
   -> 이미 SetHp때 1레벨로 세팅되어, 이후 레벨을 변경해도 CurrentHp는 그대로 
   -> 언리얼은 이런 경우를 막기 위해, 지연 생성 함수를 지원 [SpawnActorDeferred]
      . SpawnActorDeferred -> FinishSpawning -> BeginPlay
      . FinishSpawning를 호출해주고나서야, 이후 BeginPlay가 실행



언리얼 C++ 팁 
----------------------------------------------------------------------------
ㅇ 반환되는 값이 상수인 경우 const를 꼭 붙여주자
	FORCEINLINE float GetAttackRadius() const { return AttackRadius; }	

ㅇ 왠만해선 SpawnActorDeferred 사용? 
   - 차후 로직이 변경되어도 BeginPlay랑 꼬이지 않도록


언리얼 팁 
----------------------------------------------------------------------------
ㅇ플레이 중, 액터 선택시 서브화면이(카메라 화면) 너무 큰경우 아래 옵션 변경
   - Editor Preferences / Genernal / Appearance / camera 검색
   - Level Editor - Viewports / Look and Feel / Camera Preview Size 






11강. 행동트리 모델의 이해
===========================================================================================================
강의목표
----------------------------------------------------------------------------
행동 트리의 역사를 살펴보고 행동트리 모델이 가진 장점을 이해
   - BT는 FSM이 가지고 있던 고질적인 문제를 해결하는 새로운 인공지능 모델 
   - FSM에 비해서 BT가 가지는 장덤: 모듈화가 잘되어 있어 확장이 자유롭다는것
   <?> BT가 FSM(유한상태머신)패턴 인게 아니고 개선한 거였네? 뭐가 문제였고 어떻게 해결된건지 알아보기 
행동 트리 모델의 구성요소와 이를 활용한 설계방법의 학습

강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   - 인공지능 / BT

1.행동트리 개념 

2.ai컨트롤 클래스 생성 및 ABCharacterNonPlyaer에 적용 [ABAIController] 
   - ABCharacterNonPlyer의 AIControllerClass를 ABAIController로 설정
      AIControllerClass = AABAIController::StaticClass();
      AutoPossessAI = EAutoPossessAI::PlacedInWorldOrSpawned;	//배치npc, 런타임중 스폰npc 둘다 AABAIController 적용

3.블랙보드, 행동트리 애셋 생성 및 세팅
   - Artificial Intelligence/Blackboard: 인공지능모델에서 의사결정을 위한 기본데이터 저장소 [BB_ABCharacter]
   - Artificial Intelligence/Behavior Tree: [BT_ABCharacter]



행동 트리 모델의 구성 요소
----------------------------------------------------------------------------
트리에서 항상 왼쪽에 있는 노드에 우선 순위를 부여
왼쪽에서 부터 깊이 우선 탐색을 시작

ㅇ컴포짓(Composite): 부모 노드로, 다수의 행동을 컨트롤
   - 셀렉터(Selector): 여러 행동 중 하나의 행동을 지정 (중 하나지만, 데코레이터가 없는경우 기본적으로 왼쪽 행동 우선)
   - 시퀀스(Sequence): 여러 행동을 차례대로 수행
   - 패러렐(Parallel): 여러 행동을 동시에 수행

ㅇ행동 노드(Task): 컴포짓노드는 행동 노드의결과에 따라 변화한다. 
   - 성공(Succeeded): 행동의 성공
   - 실패(Failed): 행동의 실패
   - 중지(Aborted): 외부 요인으로 인한 행동의 실패
   - 진행 중(InProgress): 행동 결과를 홀딩

   -> 셀랙터 컴포짓은 성공 노드가 나오면 종료
   -> 시퀀스 컴포짓은 성공시, 다음 행동들을 진행 / 실패시 시퀀스 종료

ㅇ컴포짓 노드에 부착하는 추가 기능 
   - 데코레이터(Decorator): 컴포짓 노드가 실행되는 조건을지정
   - 서비스(Service): 컴포짓 노드가 활성화될 때 주기적으로 실행되는 부가 명령
   - 관찰자 중단(Abort): 데코레이터 조건에 부합되면 컴포짓 내 활동을 모두 중단
      . Sequence가 진행되는동안, 모두 진행되거나 도중 실패가 떠야만, 그때서야 Root로 돌아가 이전 우선순위들을 체그하는 문제
      . 즈깃 Sequence를 종료시킬때 자주 사용한다.


<?> BT는 인공지능 AI만을 위한 개념..?
  - 플레이어의 조작 -> 캐릭터 액션 에서는 인용할수 없나? 그게 FSM?
  - 고민 결과: https://carrotshake.tistory.com/68


언리얼 C++ 
----------------------------------------------------------------------------
ㅇOnPossess
	//컨트롤러가 폰에 빙의될때 호출된다.
	virtual void OnPossess(APawn* InPawn);


ㅇConstructorHelpers
	//고정적으로 두 애셋을 항상 사용할것이므로, ConstructorHelpers 사용
	static ConstructorHelpers::FObjectFinder<UBlackboardData>  BBAssetRef(TEXT(""));
	if (nullptr != BBAssetRef.Object)
	{
		BBAsset = BBAssetRef.Object;
	}


ㅇ행동트리 관련 함수들

- UseBlackboard, RunBehaviorTree
   UBlackboardComponent* BlackboardPtr = Blackboard.Get();
   //블랙보드 구동
   if (UseBlackboard(BBAsset, BlackboardPtr))
   {
      //행동트리 구동
      bool RunResult = RunBehaviorTree(BTAsset);
      ensure(RunResult);
   }

- StopTree
	//실행중인 행동트리는 AIConroller.BrainComponent에 저장된다. 이를 캐스팅
	UBehaviorTreeComponent* BTComponent = Cast<UBehaviorTreeComponent>(BrainComponent);
	if (BTComponent)
	{
		BTComponent->StopTree();
	}

- BrainComponent
	//실행중인 행동트리는 AIConroller.BrainComponent에 저장된다. 이를 캐스팅
	UBehaviorTreeComponent* BTComponent = Cast<UBehaviorTreeComponent>(BrainComponent);







12강. 행동트리 모델의 구현
===========================================================================================================
강의목표
----------------------------------------------------------------------------
NPC의 행동 트리 모델을 기획하고 언리얼 엔진에서 구현하는 방법의 학습

강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   - 인공지능 / 길찾기, BT

0. Step6 저장 

1. 블랙보드에 변수 추가 / 프로젝트 네비게이션 메쉬 활성화(길찾기 기능 활성화)
   - Place Actors 창 / Volumes / NavMeshBoundsVolume 드래그해서 씬에 설치 및 세팅
      . Brush Settings 세팅
   - 런타임중 맵이 생성됨으로, 네비 메쉬를 동적으로 변경
      . Project Settings / Navigation Mesh / Runtime Generation을 Dynamic으로 변경

2. 블랙보드 및 행동트리 수정 / BTTaskNode를 상속받는 테스크 노드 C++클래스 생성 [BTTask_FindPatrolPos] 
   - BT관련 추가할때는, Build설정에서 AI 관련 모듈들을 설정 해줘야한다.
      . "NavigationSystem", "AIModule", "GamePlayTasks"
   - 접근할 블랙보드의 키값을 전처리로 선언 [ABAI.h] 

3. NPC가 기본적으로 구현해야할 데이터를,
    네비게이터와 AI 캐릭터 간에 서로 참조하지 않도록 인터페이스로 설계 [ABCharacterAllInterface]
   - ABCharacterNonPlayer에 상속 

4. 플레이어 감지를 위한 BTService를 상속받는 서비스 노드 C++ 생성 [BTService_Detect]
   - BT의 Sequence노드에 생성한 서비스 부착 
   - BB에 ObjectKey타입의 Target 추가

5. NPC가 플레이어를 감지했을때, 추격
   - Selctor 추가, 언리얼 기본 데코레이터인 BlackBoard를 추가해 
       타겟이 설정되어 있을때만 하위의 Move To 노드를 타도록 설정
      .Blackboard Key: Target
      .Key Query: Is Set 
   - 탐색 Sequence로직도 Blackboard를 추가해, 타겟이 없을때로 설정
      .Blackboard Key: Target
      .Key Query: Is Not Set 
   - 관찰자 중단기능으로 탐색중, 플레이어를 탐지한 경우 즉시 탐색 Sequence를 종료하도록 설정

6. NPC가 추격후 공격
   - 공격 판단을 위한, BTDecorator를 상속받는 데코레이터 C++ 생성 [UBTDecorator_AttackInRange]
   - BTTaskNode를 상속받는 공격 테스크 C++ 생성 [UBTTask_Attack]
   - AttackRange 데코레이터 속성의 Inverse Condition을 체크하면, '!' 조건도 가능
   - ABCharacterBase에 상수로 박혀있는 AttackRadius 값을 Stat으로 이전 

7. NPC 공격이 끝났음을 델리게이트로
   - [ABCharacterAIInterface]에 델리게이트 생성, 세팅 함수 추가
      DECLARE_DELEGATE(FAICharacterAttackFinished);
      virtual void SetAIAttackDelegate(const FAICharacterAttackFinished& InOnAttackFinished) = 0;
   - [ABCharacterNonPlayer]에 상속, 델리게이트 변수, Set함수 생성
   - [ABCharacterBase]에서 공격 종료시 호출하는 함수 생성 (기존 ComboActionEnd는 몽타주 종료 함수로 구분해서 별도 생성) 
      .공격 종료시 호출
      .Base에서는 빈함수, ABCharacterNonPlyaer에서 상속받아 델리게이트 실행 
   - [BTTask_Attack]에서 델리게이트 생성 및 람다 콜백 세팅해서, [ABCharacterNonPlayer.OnAttackFinished] Set함수 호출
      FAICharacterAttackFinished OnAttackFinished ;
      OnAttackFinished.BindLambda(
         [&]()
         {
            //테스크가 종료되었음을 알림
            FinishLatentTask(OwnerComp, EBTNodeResult::Succeeded);		
         }
      );
      
8. 플레이어가 죽었을 때, NPC 공격 정지 
   - 세팅된 Target을 null로 바꿔줄수 있게 OnTarget Selector노드에 Detect서비스 부착

9. NPC가 공격중에 플레이어 방향으로 회전 
   - BTTaskNode를 상속받는 테스크 노드 C++ 생성 [BTTask_TurnToTarget]
   - 공격과 회전이 동시에 진행되기 위해 Selector가 아닌 Simple Parallel로 변경


언리얼 C++팁
----------------------------------------------------------------------------
ㅇ델리게이트 
   - 콜백으로 람다함수 바인드
      OnAttackFinished.BindLambda(
         [&]()
         {
                  
         }
      );


ㅇ행동트리 편집시 노드, 노드 내의 데코레이터 서비스에 복사, 붙여넣기, 자르기 등의 동작이 가능

ㅇ방향 회전 (TargetPawn을 바라보도록)
	float TurnSpeed = AIPawn->GetAITurnSpeed();
	FVector LookVector = TargetPawn->GetActorLocation() - ControllingPawn->GetActorLocation();
	LookVector.Z = 0.0f;
	FRotator TargetRot = FRotationMatrix::MakeFromX(LookVector).Rotator();
	ControllingPawn->SetActorRotation(FMath::RInterpTo(ControllingPawn->GetActorRotation(), TargetRot, GetWorld()->GetDeltaSeconds(), TurnSpeed));

ㅇ행동트리 
   - BTService를 상속받는 경우: TickNode() 함수 구현 
      .virtual void TickNode(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds) override;
   - BTDecorator를 상속받는 경우: CalculateRawConditionValue() 함수 구현 
      .virtual bool CalculateRawConditionValue(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) const override;
   - BTTaskNode를 상속받는 경우:ExecuteTask() 함수 구현
      .virtual EBTNodeResult::Type ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory) override;
      .FinishLatentTask(OwnerComp, EBTNodeResult::Succeeded): 테스트가 종료되었음을 알린다. 







13강. 헤드업 디스플레이의 구현
===========================================================================================================
강의목표
----------------------------------------------------------------------------
헤드업 디스플레이 UI 생성 방법의 이해
컴포넌트, 액터, UI 위젯의 초기화 프로세스의 학습 
언리얼 리플렉션을 활용한 유연한 데이터 연동 시스템

강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   - 플레이어/HUD

1. 헤드업 디스플레이로 사용할 UI 애셋 생성, 블루프린트 작업
   - UserWidget을 상속받는 C++ 생성 [ABHUDWidget] 
      .캐릭터와 1:1 매칭시킬 HUD의 경우, GetOwningPlayer()로 소유자를 가져올 수 있어
         지난시간에 위잿에서 Owner정보를 사용하기 위해 만들었던 ABUserWidget을 사용할 필요 없음
   - 애셋 생성: User Interface / Widget Blueprint / User Widget
   - 생성한 UI애셋이 ABHUDWidget을 상속받도록 세팅
      .블루프린트 / 우측 상단의 Graph / 중앙 상단의 Class Settings / Parent Class를 ABHUDWidget으로 변경

2. [ABPlayerController]에서 게임 시작시 위젯 생성 

3. 캐릭터 스탯을 표시할 위젯 생성 및 표시
   - User Interface / 상단의 User Widget 버튼 클릭 [WBP_CharacterStat]
   - 아래 Hrizontal Box들을 전부 선택 후 Size / Fill 선택하면 동일한 크기로 Vertical Box를 전부 채운다.
     Vertical Box   
      ㄴHorizontal Box
      ㄴHorizontal Box
      ㄴHorizontal Box
      ㄴHorizontal Box
   - WBP_ABHUD UI애셋에 방금생성한, WBP_CharacterStat을 추가

4. [ABCharacterStatComponent]의 데이터 세팅 시점 변경 
   - BeginPlay -> InitializeComponent
   - InitializeComponent가 호출되기 위해서는 생정자에서bWantsInitialzieComponent를 true로 해줘야 한다.
   - 데이터 세팅 후 출력까지 언리얼 함수들로 세팅
      ABCharacterStatComponent.InitializeComponent()
         ↓
      ABPlayerController.BeginPlay() 
         ↓
      ABHUDWidget.AddToViewport()
         ↓
      ABHUDWidget.NativeConstruct()

5. [ABHUDWidget] 구현
   - UserWidget을 상속받는 C++ 생성 [ABCharacterStatWidget]
      . WBP_CharacterStat의 Parent Class로 지정
   - Unreal Interface를 상속받는 C++ 생성 [ABCharacterHUDInterface] 
      . [ABCharacterPlayer]가 상속 및 내용 구현

<?> 헤드업 디스플레이의 경우, GetOwnPlayer()로 자기를 소유하는 컨트롤러를 
      GetOwnPlayerPawn()으로 자기를 소유하는 컨트롤러의 폰까지도 가져올수 있다.
   - 같은 UserWdiget을 상속받았는데 왜 이런게 가능하지. 저번엔 안되서 ABUserWdiget만든거 아니였나

6. [ABCharacterStatComponent]에 스탯들을 가져오는 Get함수, 스탯이 수정될때 호출되는 델리게이트 추가
   - ABCharacterPlayer에서 추가한 델리게이트에 ABHUDWdiget의 함수를 연결

7. 언리얼의 리플렉션 시스템을 이용하여, 스탯이 변경될 때마다 업데이트 UI 적용  
   - [ABHUDWidget.NativeConstruct] 구현
   - 구조체의 속성 반복 
      for (TFieldIterator<FNumericProperty> PropIt(FABCharacterStat::StaticStruct()); PropIt; ++PropIt)
      {
         const FName PropKey(PropIt->GetName());
         ....
      }

※ 리플렉션 시스템
   1.리플렉션 시스템을 사용해 언리얼 오브젝트의 특정 속성과 함수를 이름으로 검색할 수 있다.
   2.리플렉션 시스템을 사용해 접근 지시자와 무관하게 값을 설정할 수 있다.



컴포넌트, 액터, UI위젯의 초기화 과정
----------------------------------------------------------------------------
예제에서
   -컴포넌트 : 스탯 데이터 관리
   -액터 : 기능들의 실행 주체

   -> UI위젯은 액터에서 생성된 UI위젯은 적절한 시점에 컴포넌트의 데이터를 제공 받아야함 

컴포넌트.InitializeComponent //데이터 세팅, 생정자에서 bWantsInitialzieComponent=true 필요
   ↓
액터.PostInitializeComponents
   ↓ 
컴포넌트.BeginPlay / 액터.BeginPlay
   ↓
액터.CreateWidget / UI위젯.NativeOnInitialized //UI위젯 생성 및 초기화 함수 호출, 생성만 되었지 화면에 출력x
   ↓
액터.AddToViewport / UI위젯.NativeConstruct // 화면에 위젯 출력



언리얼 C++ 팁 
----------------------------------------------------------------------------
헤더
   <?> TSubclassOf / TOjbectPtr / TclassPtr?  종류에따른 용도 정리하기

소스파일
   ConstructorHelpers::FClassFinder


위젯 생성
   - CreateWidget
   - AddToViewport를 해줘야 카메라에 담긴다.   
      ABHUDWidget = CreateWidget<UABHUDWidget>(this, ABHUDWidgetClass);
      if (ABHUDWidget)
      {
         ABHUDWidget->AddToViewport();	
      }


ㅇ위젯의 생성자는 인자를 하나 받는다.
   - 헤더
   	UABHUDWidget(const FObjectInitializer& ObjectInitializer);

   - 소스파일
      UABHUDWidget::UABHUDWidget(const FObjectInitializer& ObjectInitializer) : Super(ObjectInitializer)
      {
      }


ㅇ 아마도? 
수정한 위젯을 다른 위젯 하위로 넣을 때, 수정 후 Complie -> 저장해야 
다른 위젯에서 수정된걸로 확인이 가능하다 


ㅇFNumericProperty를 사용한 구조체 순환
   - FNumericProperty
   - GetValue_InContainer
      for (TFieldIterator<FNumericProperty> PropIt(FABCharacterStat::StaticStruct()); PropIt; ++PropIt)
      {
         const FName PropKey(PropIt->GetName());

         float BaseData = 0.0f;
         // FNumericProperty의 value를 꺼내 옴
         PropIt->GetValue_InContainer((const void*)&BaseStat, &BaseData);

         float ModifierData = 0.0f;
         PropIt->GetValue_InContainer((const void*)&ModifierStat, &ModifierData);

         UTextBlock** BaseTextBlockPtr = BaseLookup.Find(PropKey);
         if (BaseTextBlockPtr)
         {
            (*BaseTextBlockPtr)->SetText(FText::FromString(FString::SanitizeFloat(BaseData)));
         }

         UTextBlock** ModifierTextBlockPtr = ModifierLookup.Find(PropKey);
         if (ModifierTextBlockPtr)
         {
            (*ModifierTextBlockPtr)->SetText(FText::FromString(FString::SanitizeFloat(ModifierData)));
         }
      }
   

ㅇ문자열 조합
		const FName TextBaseControlName = *FString::Printf(TEXT("Txt%sBase"), *PropIt->GetName());

      // Float값들을 FString::SanitizeFloat()로 이쁘제 정렬 후 
      // FText::FromString()로 스트링으로 변환
      (*BaseTextBlockPtr)->SetText(FText::FromString(FString::SanitizeFloat(BaseData)));



에러노트
----------------------------------------------------------------------------
ㅇ HpBar = Cast<UABHpBarWidget>(GetWidgetFromName(TEXT("WidgetHpBar")));
   - WidgetBar로 Hp를 빼먹었다가 실행하자마자 에디터가 뻗어서 30분동안 찾아해맸다.


ㅇWBP_ABHUD(Parent:ABHUDWidget)의 하위에 
  WBP_CharacterStat(Parnet:ABCharacterStatWidget), WBP_ABHUD하위에선 WidgetCharacterStat로 이름 변경 

문제1) WidgetCharacterStat을 WBP_ABHUD애셋에서 이름변경 때 오타 GetWidgetFromName 실패
+
문제2) UI애셋의 Class parent가 ABCharacterStatWidget아닌, 기본 User Widget으로 되어 있어 Cast실패 

에러)
ABHUDWidget.AddToViewport() -> ABHUDWidget().SetupHUDWidget -> ABHUDWidget.NativeConstruct / ABCharacterStatWidget.NativeConstruct()가 호출되야하는데 
ABCharacterStatWidget.NativeConstruct()가 호출되지 않아, 변수들 초기화가 안되어
이후 UpdateStat() 접근시 변수가 null이라 에러 
ABCharacterStatWidget.UpdateStat()에서 에러가 난것처럼 보임 



	CharacterStat = Cast<UABCharacterStatWidget>(GetWidgetFromName(TEXT("WidgetCharacterStat")));
	ensure(CharacterStat);

	//컨트롤러가 빙의하고 있는 폰을 가져와 캐스팅
	IABCharacterHUDInterface* HUDPawn = Cast<IABCharacterHUDInterface>(GetOwningPlayerPawn());
	if (HUDPawn)
	{
		HUDPawn->SetupHUDWidget(this);
	}
   







14강. 게임 플로우 다듬기
===========================================================================================================
강의목표
----------------------------------------------------------------------------
게임을 이루는 전체 구성 요소 파악, 이를 보강
전체 게임 플로우가 잘 동작하도록 캐릭터 스탯과 아이템 다듬기


강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
   플레이어/입력
   플레이어/HUD
   폰/위젯
   데이터/애셋
   데이터/테이블

1. NPC, 플레이어가 죽었을때 처리 
   - NPC: 인공지능 비활성화
   - 플레이어: 입력을 더이상 전달하지 않도록 입력 비활성화, BeginPlay에서 입력 활성화 추가

2. 이동속도 스탯 변경시 캐릭터에 적용

3. 아이템 장착시 스탯 변경
   - ABItemData를 상속받은 스크롤 데이터 C++ 생성 [ABScrollItemData]
   - ABItemData를 상속받은 포션 데이터 C++ 생성 [ABPotionItemData]
   - ABIP_PotionTest, ABIS_ScollTest 아이템 데이터 애셋 제거  
   - 무기, 포션, 스크롤 각 class를 상속받는 데이터 에셋 종류별로 추가 
   - 언리얼 제공하는 기능을 사용해, 여러 애셋을 시트로 관리

4. 각 아이템 효과 구현 
   - 세 아이템의 헤더를 묶은 헤더 추가 [ABItems.h]
   - [ABCharacterStatComponent]에 회복, 스크롤 스택 적용 기능 추가 
   - [ABCharacterBase]에 기능 적용 부분 구현

   <!> ABCharacterStatComponent의 SetBaseStat(), AddBaseStat() 두곳다 직접 BaseSet 변수에 값을 넣고 델링게이트, 브로드 캐스팅
      -> AddBaseStat에서 변쉥 직접 넣지 ㅁ라고 SetBaseStat()을 이용하는게 좋지 않았을까 

   <!> 스크롤이 ABCharacterStat 통째로 가지는것보다 ER처럼 StatType과 Value 쌍을 가지는게 좋지 않았을가 
         스탯이 많아질수록 불필요한 값들을 같이 들고 있게 될텐데 

5. UI HpBar 기능 확장 - 텍스트 추가 
   - Overlay 패널을 두어 하위 항목들이 겹쳐서 표현되게 한다. 

6. 여러 애셋 관리 
   - 묶을 애셋들을 드래그 / 우클릭 / Asset Actions / Bulk Edit via Property  Matrix... 
   - Grid창, 오른쪽 Display창의 핀을 클릭해주면 표에 해당 컬럼이 적용된다. 


언리얼 C++ 팁 
----------------------------------------------------------------------------
폴더에서 직접 텍스트파일을 추가하는 경우 라이더가 인식 못함
   - 라이더의 솔루션에서 생성하기 

UI 팁 
   - 여러 위젯을 겹치고 싶으면 Overlap Panel 사용







15강. 게임의 완성
===========================================================================================================
강의목표
----------------------------------------------------------------------------
게임 모드를 활용한 게임의 승패조건을 설정하는 과정의 이해
CPP에서 블루프린트로 확장하는 방법의 학습 
SaveGame 객체를 활용한 간편한 게임 데이터 저장과 불러오기 
최종 게임의 패키징


강의내용
----------------------------------------------------------------------------
ㅇ이번 실습에서 다루는 게임 프레임웍 요소
- 게임/모드
- 게임/상태
- 플레이어/상태
- 데이터/저장


게임 모드 
----------------------------------------------------------------------------
언리얼은 여러 프로젝트에 돌려쓰며 게임 로직을 얹을수 있도록, 분리된 게임 레이어를 제공 
   - GameMode
      .게임의 전제 조건들 관리 (ex. 클리어 조건 값들(클이어점수))
      .접근 방식: GetWorld()->GetAuthGameMode()  (예제에서는 생성한 게임모드인지 Inteface를 생성해 캐스팅)
   - GameState
   - PlayerState

<?> GameState, PlayerState 엑터 프레임워크 알아보기


1. [ABGameMode]에 점수 추가, NPC가 죽었을때 점수를 체크 -> 클리어시 보상단계 전에 return
   - GetWorld()->GetAuthGameMode(); 게임모드를 어디서든 가져올수 있다.

2  Unreal Interface를 상속받는 C++ 생성 [ABGameInterface]
   - GetWorld()->GetAuthGameMode()로 직접 참고하지않고, 간접적으로 참조하기 위해 
   - 별도 생성한 게임모드인지 판단을 위해
   - ABGameMode에 상속
   - 점수, 클리어, 실패 등 게임 흐름과 관련된 함수들 추가 
   - 게임모드가 직접 UI에 접근하지 않음. 보고를 받으면 담당 엑터에게 명령하는 방식으로 설계
<~> 예제에서는 GameMode에서 진행했지만, 보통은 GameState에서 다룰듯함. 
      GaeMode는 정말 ER의 루미아, 코발트 처럼 모드쪽을 다뤄지 않을까 싶다.

3. 플레이어가 죽었을때, GameMode에 보고

4. [ABGameMode]에서 점수변경, 클리어, 플레이어 사망을 보고 받으면, [AABPlayerController]에게 UI갱신 등을 요청 

5. 각 요청에따라 UI 갱신을 블루프린트로 
   - 블루프린트와 호환되는 UFUNCTION()속성의 함수 생성 
      //K2_ 접두사: 블루프린트의 전신인 kismet 기능을 의미 (관습적으로 언리얼 소스코드에서 사용됨)
      //           예제에선 블루프린트에서 호출되는 함수로 일반함수와 구분을 위해 사용
      //BlueprintImplementableEvent: 블루프린트에서 이벤트처럼 호출되기 위해
      //DisplayName = "OnScoreChagnedCpp": 블루프린트상에서의 이름, C++의 함수임을 나타내기위해 Cpp 접미사 사용
      //함수 본문을 구현하지 않아도 언리얼 엔진이 UFUNCTION 매크로를 보고 이벤트임을 확인, 자동으로 본문을 만들어 준다. 
      UFUNCTION(BlueprintImplementableEvent, Category = UE_GAME, Meta = (DisplayName = "OnScoreChagnedCpp"))
      void K2_OnScoreChanged(int32 NewScore);
   - Content / ArenaBattle / Blueprint / BP_ABGame_Mode
      .GameMode Override를 ABGameMode -> BP_ABGame_Mode로 변경
      .K2 이벤트들을 추가 
      
6. 시작시 UI출력 기존 코드 주석처리, 블루프린트로 대체
   - Content / ArenaBattle / Blueprint / WBP_Player_Score 
      .Parent Class를 PlayerController->ABPlayerController로 변경
   - WBP_ABHUD에 WBP_PlayerScore 추가 
   - BP_ABPlayerController 블루프린트에 스코어 갱신 작업

7. 저장 기능 
   - SaveGame을 상속받는 C++ 생성 [ABSaveGame]
      .SaveGame : 언리얼에서 게임 저장을 위해 준비한 언리얼 오브젝트
   - UGameplayStatics::LoadGameFromSlot(TEXT("Player0"), 0) : (저장할 파일 이름, 플레이어 번호) // 싱글의 경우 항상 0
      .#include "Kismet/GameplayStatics.h"	//UGameplayStatics사용을 위해  
 	- Save: SaveGameInstance = Cast<UABSaveGame>(UGameplayStatics::LoadGameFromSlot(TEXT("Player0"), 0)); 
   - Load: UGameplayStatics::SaveGameToSlot(SaveGameInstance, TEXT("Player0"), 0)
   - Directory: ArenaBattle_Chapter3\SaveGames\Player0.sav

8. 재시작 시 리트라이 카운트 증가 
   - BP_ABPlayerController에 리트라이 카운트 갱신 작업

9. 빌드
- 상단 중앙 Platforms / Windows 
   . DebugGame
   . Development
   . Shipping : 가장 빠른 빌드, 단 디버깅 불가

- Platforms / Packaging Setting
   . Advanced / Additional Asset Directories to Cook (※ Cook : 애셋들을 플랫폼에 맞춰 변환하는 과정)
   . 아이템 애셋들이 코드나 블루프린트에서 강한참조를 하고 있지않아 패키징에 포함되지 않음
       해당 메뉴에 아이템 폴더를 추가해준다.
   . Advanced / List of Maps to include in a packaged build: Maps/Main 세팅




언리얼 C++
----------------------------------------------------------------------------
게임모드를 가져오는 방법
   - GetWorld()->GetAuthGameMode();
   - 별도 생성한 게임모드인지 확인을 위해 Inteface를 생성해 캐스팅 
   

블루프린트 
   - 빈공간에 우클릭 했을 때랑, 이미 생성된거에서 화살표를 빼 빈공간을 선택했을 때 
      생성할 수 있는 종류가 다름


<?> 게임 UI들을 띄우며, 게임 흐름 자체가 블루프린트로 돌아가게 되어버림.
    코드에서 흐름을 다루는것보다 더 좋은건가..? 
   - UI갱신 로직들을 딸각으로 처리할수 있는건 획기적
  


ㅇUE_LOG 사용 스텝
1. 헤더에 로그 매크로를 사용해 정의
   DECLARE_LOG_CATEGORY_EXTERN(LogABPlayerController, Log, All);  
2. 소스파일에 로그 매크로를 사용해 구현
   DEFINE_LOG_CATEGORY(LogABPlayerController);
3. 사용
   UE_LOG(LogABPlayerController, Error, TEXT("Save Game Error!"));













































=================================================================================================================================================
Part4
=================================================================================================================================================


1강. 언리얼 게임플레이 어빌리티 시스템 개요
===========================================================================================================
강의목표
----------------------------------------------------------------------------
게임플레이 어빌리티 시스템 (GAS)을 구성하는 주요 개념과 핵심 구성요소의 학습 
앞으로 다룰 실습 프로젝트 구성의 이해
향후 실습 구현 과정의 이해
C++언어로 게임플레이 어빌리티 시스템 학습해야 하는 이유


강의내용
----------------------------------------------------------------------------
ㅇ공식 홈페이지: https://bit.ly/uegasoverview

★ UE게임 샘플: Lyra Starter Game 라일라 스타트 게임 프로젝트 
   - 완성도가 높은 언리얼 제공 샘플 프로젝트 
   - 게임 구현시 설계구조 및 기능 참고하기 



게임 플레이 어빌리티 시스템(GAS) 프레임 웍 
----------------------------------------------------------------------------
ㅇ액터가 소유하고 발동할 수 있는 어빌리티 및 액터 간의 인터랙션 기능을 제공하는 프레임 웍 
   - 복잡한 서로간의 상호작용(서로에게 스킬, 피해 및 영향을 미치는 등)을 쉽게 하기 위해 사용
   - 모든 게임에 사용가능하도록 확장가능

ㅇGAS 프레임웍의 장점
   - 유연성과 확장성
   ★ 모듈러 시스템: 각 기능에 대한 의존성이 최소화 되도록 설계
   - 네트워크 지원: 멀리플레이어 게임에서도 활용 가능하도록 설계  (강의에서는 제외)
   - 데이터 기반 설계: 데이터를 기반으로 동작 (강의에서 심도있게 다루지는 않을 예정)

ㅇ 단점
   - 오버헤드: 작은 규모의 프로젝트에는 복잡한 구조가 오히려 부담이 될 수 있다.
      .간단한 상태머신으로 완성가능한 게임은 굳이 사용할 필요 없음


게임플레이 어빌리티 시스템의 핵심 구성 요소 
----------------------------------------------------------------------------
ㅇASC 어빌리티 시스템 컴포넌트 - 어빌리티 시스템 컴포넌트
   .가스 프레임 워크를 관리하고 처리하는 액터의 중앙 처리 장치

ㅇTag 게임플레이 태그 - 게임 플레이 태그 / 게임플레이 태그 컨테이너 

ㅇGA 게임플레이 어빌리티 - 게임 어빌리티 / 어빌리티 태스크 / 게임플레이 이벤트
   - 모든 스킬, 액션들이 발동해서 시작

ㅇGE 게임플레이 이펙트 - 게임플레이 이펙트 / 이펙트 실행 계산 / 장식 이펙트 게임플레이 큐 
   - 효과가 아닌 영향의 개념 
   - 어빌리티에 대한 결과, 효과들을 시스템에 알려주도록 구성
   - 어트리뷰트에 영향을 주는 요소들 

ㅇAttribute 어트리뷰트 - 게임플레이 어트리뷰트 데이터 / 어트리뷰트 세트
   - 스탯과 같은 데이터들

ㅇGamePlay Cue: 연출 이펙트 


실습 프로젝트의 구성의 특징 
----------------------------------------------------------------------------
주 게임 모듈이 아닌 보조 게임 모듈을 사용해 GAS에 관련된 모든 기능을 구현 
AreanaBattle
   - 기본 액터, 캐릭터, PC/NPC 캐릭터
   - 기본 게임 및 물리설정 

ArenaBattleGAS
   - 확장된 GAS 게임모드 및 PC/NPC 캐릭터 
   - GAS 관련 기능 
   - GAS 연동 UI 







2강. 게임플레이 어빌리티 시스템의 시작
===========================================================================================================
강의목표
----------------------------------------------------------------------------
게임플레이 어빌리티 시스템(GAS) 기본 설정 방법의 학습
   - 어빌리티 시스템 컴포넌트의 생성과 초기화
   - 게임플레이 어빌리티의 제작과 활용
   - 게임플레이 태그의 활용

다양한 구현 방법이 가진 장단점의 이해 


강의내용
----------------------------------------------------------------------------
ㅇ3가지 방법으로 기능 구현
   - 기존방식대로 액터에 해당 기능을 구현
   - 게임플레이 어빌리티 시스템으로 구현
      .액터로부터 기능 분리 
   - 게임플레이 어빌리티 시스템에 게임플레이 태그를 부여해 구현
      .의존성 없는 설계 가능, 어빌리티 교체등의 유연성, 확정성 높음


ㅇ이번 실습에서 다룰, GAS 핵심 구성 요소 
   - 어빌리티 시스템 컴포넌트
   - 게임플레이 태그
   - 게임플레이 태그 컨테이너
   - 게임플레이 어빌리티


1. ABFountain을 상속받는 C++ 생성 및 기능 구현 [ABGASFountain]

2. GAS를 이용한 기능 구현
   - 일반적으로 GAS를 소유하는 액터는 AbilitysystemInterface를 상속시킨다. 
      . ABGASFountain.h에 인터페이스 상속, 인터페이스의 ASC반환 함수 오버라이드 
      	virtual class UAbilitySystemComponent* GetAbilitySystemComponent() const override;
   
3. GameAbility를 상속받는 C++ 생성 및 기능 구현[ABGA_Rotate]
   - ABGA_Rotate스펙을 생성해서, ABGASFountain에 부여
   - 스펙의 핸들을 이용해 GA 활성화

4. 게임플레이어 태그 추가 및 설정
   - Projec Settings / Project / GameplayTags / Gameplay Tag List 애서 태그 추가
      . Actor.Action.Rotate -> 3단구조의 태그 생성
   - [ABGameplayTag.h] 생성, 전처리만으로 태그를 지정할수 있게 전처리기 추가

5. ABGAS_Rotate GA에 태그 등록 및, ASC와 GA간의 의존성 제거 
   - GA의 생성자에서 태그 설정
         AbilityTags.AddTag(ABTAG_ACTOR_ROTATE);
         //활성화시 태그 추가
         ActivationOwnedTags.AddTag(ABTAG_ACTOR_ISROTATING);
   - ASC에서 태그를 사용해 활성화, 비활성화 
         FGameplayTagContainer TargetTag(ABTAG_ACTOR_ROTATE);
      
         if(!ASC->HasMatchingGameplayTag(ABTAG_ACTOR_ISROTATING))
         {
            ASC->TryActivateAbilitiesByTag(TargetTag);
         }
         else
         {
            //Cancel시 &연산자 주의 
            ASC->CancelAbilities(&TargetTag);
         }
   - ABGASFountain에 시작시 장착 시킬 GA들을 TArray로 관리 
      .모든 GA는 UGameplayAbility를 상속받으므로 UGameplayAbility형 TArray로 관리
      .블루프린트로 세팅
      .UABGA_Rotate를 지정해서 장착하던 부분제거
      .ABGA_Rotate.h헤더 제거


어빌리티 시스템 컴포넌트 ASC(Ability System Component)
----------------------------------------------------------------------------
액터에 단 하나만 부착 가능 
액터는 부착된 ASC를 통해 게임플레이 어빌리티를 발동시킬 수 있음.
ASC를 부착한 액터 사이에 GAS 시스템의 상호작용이 가능해짐


게임플레이 어빌리티 GA (Gameplay Ability)
----------------------------------------------------------------------------
ㅇASC가 발동시킬수 있는 액션 명령 

ㅇGA의 발동 과정
   1.ASC에 어빌리티를 등록: ASC의 GiveAbility함수에 발동할 GA의 타입을 전달
      .발동할 GA 타입 정보를 게임플레이 어빌리티 스펙(GameplayAbilitySpec)이라 함
   2.ASC에게 어빌리티를 발동하라고 명령: ASC의 TryActivateAbility함수에 발동할 GA의 타입을 전달
      .ASC에 등록된 타입이면 GA의 인스턴스가 생성됨
   3.발동된 GA에는 발동한 액터와 실행 정보가 기록됨
      .SpecHandle: 발동된 어빌리티에 대한 핸들
      .ActorInfo: 어빌리티의 소유자와 아바타 정보
      .ActivationInfo: 발동 방식에 대한 정보

ㅇ GA의 주요 함수 
   - CanActivateAbility:어빌리티가 발동될 수 있는지 파악
   - ActivateAbility: 어빌리가 발동될 때 호출
   - CancelAbility: 어빌리티가 취소될 때 호출
   - EndAbility  : 스스로 어빌리티를 마무리할 때 호출
   

게임플레이 태그의 활용
----------------------------------------------------------------------------
ㅇFName으로 관리되는 경량의 표식 데이터
   - 액터나 컴포넌트에 지정했던 태그와 다른 데이터

ㅇ프로젝트 설정에서 생성 및 관리
   - 결과는 DefaultGameplayTags.ini 파일에 저장됨

ㅇ계층 구조로 구성되어 있어 체계적인 관리 가능 
   - ex. Actor.Action.Rotate: 행동에 대한 태그 / Actor.State.IsRotating 상태에 대한 태그

ㅇ게임플레이 태그 저장소: GameplayTagContainer
   - 계층 구조를 지원하는 검색 기능 제공
   - HasTagExact, HasAny, HasAnyExact, HassAll,HasAllExact: 

ㅇGAS 시스템에서만 사용되는게아닌, GAS를 사용하지 않더라도 유용한 시스템


게임플레이 어빌리티와 게임플레이 태그
----------------------------------------------------------------------------
ㅇGA에는 이미 다양한 태그 컨테이너가 정의되어 있다.

ㅇGA에 부착한 태그
   ★ 어빌리티에 지정한 태그 (AbilityTags 태그 컨테이너)
      .해당 어빌리티를 대신해서 태그로 조작 가능 
   
ㅇGA에 대해 다양한 실행조건의 설정
   ★ ActivationOwnedTags: 어빌리티 실행시 태그 설정
      . ActivationOwnedTags에 태그를 세팅하면, 
         GA가 활성화 되는 동안에 세팅된 태그가 ASC에 활성화 된다. 
   - CancelAbilitiesWithTag: 태그로 어빌리티 취소
   - BlockAbilitiesWithTag: 태그로 어빌리티 차단
   - ActivationRequireTags: 태그가 있어야만 어빌리티 실행
   - ActivationBlockedTags: 태그가 있으면 어빌리티 실행 차단
   - SourceRequiredTags: 시전자가 태그가 있어야 어빌리티 실행
   - SourceBlockedTags: 시전자에 태그가 있으면 어빌리티 차단
   - TargetRequiredTags: 시전 대상에 태그가 있어야 어빌리티 실행
   - TargetBlockedTags: 시전 대상에 태그가 있으면 어빌리티 차단 

ㅇ게임플레이 태그와 블루프린트를 사용하면 특정 C++ 헤더에 의존성이 없는 설계가 가능





3강. 캐릭터 입력 처리
===========================================================================================================
강의목표
----------------------------------------------------------------------------
플레이어 캐릭터의 게임 플레이 어빌리티 시스템 설정 방법의 학습 
플레이어 캐릭터의 입력에 따른 게임플레이 어빌리티 발동 구현
어빌리티 태스크의 활용 방법의 학습 
게임플레이 어빌리티 시스템의 디버깅 방법의 학습


강의내용
----------------------------------------------------------------------------
이번 강의에서 다룰 핵심 구성 요소
어빌리티 시스템 컴포넌트 ASC
게임플레이 태그, 게임 플레이 태그 컨테이너
게임플레이 어빌리티 GA, 어빌리티 태스크


1. 블루프린트로 게임모드 생성 [BP_ABGASGameMode]
   - Project Settings / Maps&Modes / Default Modes를 BP_ABGASGameMode로 변경

2. PlayerState를 상속받는 C++생성 [ABGASPlayerState]
   ABCharacterPlayer를 상속받는 C++생성 [ABGASCharacterPlayer]

3. ABGASPlayerState, ABGASCharacterPlayer에 GAS 기본 세팅
   - 헤더
      .헤더 추가
            #include "AbilitySystemInterface.h"
      .인터페이스 상속
            , public IAbilitySystemInterface
      .인터페이스 함수 override
            virtual class UAbilitySystemComponent* GetAbilitySystemComponent() const override;
      .ASC 변수 생성
            UPROPERTY(EditAnywhere, Category = GAS)
	         TObjectPtr<class UAbilitySystemComponent> ASC;
   -소스코드 
      . 헤더 추가
            #include "AbilitySystemComponent.h"
      . 생성자에서 ASC 생성
            AABGASPlayerState::AABGASPlayerState()
            {
               ASC = CreateDefaultSubobject<UAbilitySystemComponent>(TEXT("ASC"));
            }
      . 인터페이스 함수 구현
            UAbilitySystemComponent* AABGASPlayerState::GetAbilitySystemComponent() const
            {
               return ASC;
            }
   -ABGASCharacterPlayer는 나중에 ABGASPlayerState에서 생선한 GAS를 넘겨 받고, 처음에는 nullptr로 설정해준다.

4. ABGASCharacterPlayer에 ASC 완성
   - 컨트롤러가 폰에 빙의될때 호출되는 PossessedBy()함수를 사용하여 PlayerState의 ASC를 넘겨받는다.
		ASC = GASPS->GetAbilitySystemComponent();
		ASC->InitAbilityActorInfo(GASPS, this); //Owner는 PlayerState
   - 시작시 장착할 GA들 TArray로 관리 (+ 블루프린트) + PossessedBy에서 장착

5. ABGASCharacterPlayer를 상속받는 블루프린트 생성 [BP_ABGASCharacterPlayer]
   - BP_ABGASGameMode의 Default Pawn Class를 BP_ABGASCharacterPlayer로 설정
   - Player State Class도 ABGASPlayerState로 변경

6. GAS로 점프 구현 
   - BP_ABGASCharacterPlayer 블루프린트 편집에서 GAS로 검색, Start Abilities에 언리얼이 기본제공하는 점프 GA 추가
   - 입력을 받기위해 SetupPlayerInputComponent() 사용 
   - UEnhancedInputComponent 사용
      . UEnhancedInputComponent는 입력과 함수의 맵핑시, 추가 데이터를 맵핑된 함수에 전달 가능 
      . GiveAbility때 스펙의 InputID를 지정, 함수가 호출됬을때 받은 InputID에 따라 GA를 활성화
            FGameplayAbilitySpec StartSpec(StartAbility);
            StartSpec.InputID = InputId++;
            ASC->GiveAbility(StartSpec);

7. GAS, AT로 공격 구현
   - GameplayAbility를 상속받는 C++ 생성 [ABGA_Attack]
   - 애니메이션 몽타주 관련 AT 생성 [UAbilityTask_PlayMontageAndWait]
         UAbilityTask_PlayMontageAndWait* PlayAttackTask = 
            UAbilityTask_PlayMontageAndWait::CreatePlayMontageAndWaitProxy(this, TEXT("PlayAttack"), ABCharacter->GetComboActionMontage());
   - ASC에서 AT에 델리게이트 구독 후 실행 
         PlayAttackTask->OnCompleted.AddDynamic(this, &UABGA_Attack::UABGA_Attack::OnCompleteCallback);
         PlayAttackTask->OnInterrupted.AddDynamic(this, &UABGA_Attack::UABGA_Attack::OnInterruptedCallback);
         PlayAttackTask->ReadyForActivation();
   - ABCharacterBase의 몽타주 참조부분을 ABGASCharacterPlayer 생정자로 이전
      .애니메이션 데이터도 GAS폴더로 이전
   - ABGASCharacterPlayer.EnhancedInputComponent에 AttackAction 추가
   - BP_ABGASCharacterPlayer 블루프린트의 Start Abilities에 ABGA_Attack 추가 

8. 입력에 대한 어빌리티들을 따로 관리, 모든 입력으로 확장할 수 있게 설계 변경
   - BP_ABGASCharacterPlayer 블루프린트의 Start Abilities들을 Start Input Abilities로 이전 

9. ABGA_Attack에서 CharacterMovementComponent를 사용해, 공격중 이동할수 없도록 세팅

10. 공격중인지 상태를 알 수 있게, Tag 추가 
   - 생성했던 GA들을 상속받는 블루프린트 생성, 블루프린트에서 Tag를 붙여준다.
   - BP_ABGASCharacterPlayer의 Start Input Abilities를 생성한  블루프린트들로 교체
   - 인게임 틸드(~)키 -> showdebug abilitysystem을 입력해줘 태그 동작 로그 확인




플레이어 캐릭터의 ASC 설정 
----------------------------------------------------------------------------
ㅇ네트웍 멀티플레이를 감안했을 때, 서버에서 보관할 데이터와 실제 조종하는 데이터를 분리해서 관리
   - 주기적으로 플레이어 정보를 배포하는 PlayerState액터를 사용 
      -> Owner를 PlayerState로 설정, Avatar를 Character로 설정하는것이 일반적
   - 실제 게임에서의 상호작용은 폰이 담당, 플레이어스테이트와 폰의 역할 구분이 필요

ㅇOwnerActor: GAS 프레임워크의 데이터를 담당하는 액터
  AvartarActor: 물체와 상호작용하는 비주얼적인 부분을 담당하는 액터
 
ㅇ예제에서 사용할 방식
   - OwnerActor: PlayerState
   - AvartarActor: Character
   - PlayerState에서 ASC를 생성, 생성된 ASC포인트럴 Character에게 넘겨준다.
   - 발동한 GA들은 대부분 캐릭터의 중심으로 진행되지만 
      GA로 인한 결과는 ASC가 데이터로 보관, 이것들을 실시간으로 서버에서 클라이언트로 전송


게임플레이 어빌리티 스펙(Spec)
----------------------------------------------------------------------------
게임플레이 어빌리티의 현재 상태와 같은 다양한 정보를 담고 있는 구조체
ASC는 직접 어빌리티를 참조하지 않고, 스펙 정보만 가지고 있음
ASC로부터 어빌리티를 다루고자 할 경우, 스펙에 있는 Handle을 사용
핸들값은 전역으로 설정되어 있으며 스펙 생성시 자동으로 1씩 증가, 기본값 -1
어빌리티 정보: 스펙
어빌리티 인스턴스에 대한 레퍼런스: 스펙 핸들


어빌리티 시스템 컴포넌트의 입력처리
----------------------------------------------------------------------------
ㅇ스펙에는 입력 값을 설정하는 필드, InputID가 제공됨.
   - FindAbilitySpecFromInputID: ASC에 등록된 스펙을 검사해 입력에 매핑된 GA를 찾을 수 있음
ㅇ사용자 입력이 들어오면 ASC에서 입력에 관련된 GA를 검색
ㅇ해당 GA를 발견하면, 현재 발동 중인지를 판별 
   - AbilitySpecInputPressed: GA가 발동중이면 입력이 왔다는 신호를 전달
   - TryActivateAbility: GA가 발동중이지 않았으면 새롭게 발동시킴
ㅇ입력이 떨어지면 동일하게 처리
   - AbilitySpecInputReleased: GA에게 입력이 떨어졌다는 신호를 전달

ㅇ InputID 주체로 설계시, 모든 GAS시스템에서 공통적으로 입력을 처리할 수 있는 범용적인 설계 가능


게임플레이 어빌리티의 인스턴싱 옵션
----------------------------------------------------------------------------
NonInstanced: 인스턴싱 없이 CDO에서 일괄 처리
InstancedPerActor: 액터마다 하나의 어빌리티 인스턴스를 만들어 처리 (primary Instance)
InstancedPerExecution: 발동시 인스턴스를 생산함 (Default)

※ 네트웍 리플리케이션까지 고려했을 때, InstacedPerActor가 무난


어빌리티 태스크 AT의 활용
----------------------------------------------------------------------------
ㅇGA의 실행(Activation)은 한 프레임에서 이뤄진다.
ㅇGA가 시작되면 EndAbility함수가 호출되기까지는 끝나지 않음

ㅇ애니메이션 재생 같이 시간이 소요되고 상태를 관리해야 하는 어빌리티의 구현 방법
   ★ "비동기적"으로 작업을 수행하고 끝나면 결과를 통보받는 형태로 구현
   - 이를 위해 GAS는 어빌리티 태스크를 제공하고 있음

ㅇAT의 활용 패턴
   1. AT에 종료 델리게이트 선언
   2. GA는 AT를 생성한 후 바로 델리게이트를 구독
   3. GA는 구독설정이 완료되면 AT를 구동: AT의 ReadyForActivation 함수 호출
   4. AT의 작업이 끝나면 GA의 콜백 호출
   5. 콜백에서? EndAbility함수를 호출해 GA 종료

ㅇ GA는 필요에 따라 다수의 AT를 사용해 복잡한 액션 로직을 설계 가능



에러노트
----------------------------------------------------------------------------
ㅇ GA가 실행되는데 종료가 들어욎 않는 상황 
   - ABGA_Attack의 ActivateAbility가 들어왔지만 
      UAbilityTask_PlayMontageAndWait의 OnCompleted델리게이트가 브로드 캐스팅을 안함 -> OnCompleteCallback 호출x -> EndAbility 호출x 
   - EndAbility의 MovementMode 세팅이 되지 않아 캐릭터가 굳는 문제
      	ABCharacter->GetCharacterMovement()->SetMovementMode(EMovementMode::MOVE_Walking);
 
   -원인 : 몽타주 애셋의 폴더를 변경하고 디렉토리를 변경하지 않아, 몽타주가 비어있던 상황 -> 몽타주 시작 x -> UAbilityTask_PlayMontageAndWait가 종료를 감지할리 없음
   	static ConstructorHelpers::FObjectFinder<UAnimMontage> ComboActionMontageRef(TEXT("/Script/Engine.AnimMontage'/Game/ArenaBattleGAS/Animation/AM_ComboAttack.AM_ComboAttack'"));





4강. 캐릭터 콤보 공격의 구현
===========================================================================================================
강의목표
----------------------------------------------------------------------------
게임플레이 어빌리티GA 를 활용한 콤보 공격의 구현
게임플레이 어빌리티GA 와 어빌리티 태스크AT 동작의 이해 
블루프린트에서 활용 가능한 어빌리티 태스크AT 설정 방법의 학습


강의내용
----------------------------------------------------------------------------
ㅇ캐릭터 콤보 공격 구현
   1.ABCharacterBase에 있는 ComboActionData를 가져와서 저장

   2. 몽타주를 항상 처음부터 재생이 아닌, 섹션을 지정해서 재생하도록 변경
      
   3. 타이머 세팅, 타이머 안에 입력이 들어오면 다음 섹터의 몽타주 재생 
      - GA에서 이미 몽타주 관련한 기능들을 많이 제공하고 있다. MontageJumpToSection도 그중 하나
      - ActivateAbility()에서 타이머 발동
      - InputPressed()에서 콤보 입력 플래그 세팅 
      - EndAbility()에서 모든 콤보 관련 데이터 초기화

ㅇ상태를 가지는 점프 어빌리티의 구현 (점프동안 IsJumping 태그가 계속 활성화)
   4.GameplayAbility를 상속받는 C++ 생성 [ABGA_Jump]
   5.AbilityTask를 상속받는 C++ 생성 [ABAT_JumAndWaitForLanding] 
   6.언리얼이 제공하는 Character의 착지 델리게이트를 사용하여 착지시 ABAT_JumAndWaitForLanding 종료
      - ACharacter의 Jump() 호출 전 LandedDelegate 구독
      - AT종료시 구독 취소
   7. ABGA_Jump에서 ABAT_JumAndWaitForLanding 생성 및 델리게이트 구독 후 활성화
   8. ABGA_Jump를 상속받는 블루프린트 생성 [BPGA_Jump]
      - BP_ABGASCharacterPlayer의 Start Input Abilities를 BPGA_Jump로 변경

9.AT를 블루프린트에서 호출
      //OwningAbility를 인자로 받는건 당연한거라 Default로 두고 Hide로 숨겨놓는게 일반적
      UFUNCTION(BlueprintCallable, Category="Ability|Tasks", meta = (DisplayName="JumAndWaitForLanding",
         HidePin = "OwningAbility", DefaultToSelf = "OwningAbility", BlueprintInternalUseOnly = "TRUE"))
      static UABAT_JumAndWaitForLanding* CreateTask(UGameplayAbility* OwningAbility); 

      UPROPERTY(BlueprintAssignable)
      FJumpAndWaitForLandingDelegate OnComplete;

   - JumpAndWaitForLandingTask AT를 생성 및 활성화 시키던 부분 주석처리, BPGA_Jump 블루프린트 Event Graph에서 진행
   - BPGA_Jump 블루프린트에서 Activation Blocked Tags에 Character.State.IsAttack을 추가해
      IsAttack 태그가 활성화 된 동안에는 점프 AT가 동작하지 못하게 Block
   - BPGA_Attack에도 IsJumping을 추가해 공격중에 점프를 하지 못하게 Block


어빌리티 태스크 AT의 제작 규칙 
----------------------------------------------------------------------------
ㅇUAbilityTask 클래스를 상속받아 제작
ㅇAT 인스턴스를 생성해 반환하는 static함수를 선언해 구현한다.
ㅇ시작과 종료 처리를 위해 Activate와 OnDestory 함수를 Override해 구현
ㅇ일정시간이 지난 후 AT를 종료하고자 한다면,
   활성화시 SetWaitingOnAvartar 함수를 호출해 Waiting 상태로 설정한다.
ㅇ만일 Tick을 활성화하고 싶다면 bTickingTask 값을 true로 설정
ㅇAT가 종료되면, GA에 알려줄 델리게이트를 선언, AT가 종료되면 델리게이트를 브로드캐스팅


GA와 AT사이의 실행 흐름 
----------------------------------------------------------------------------
1. GA [AT 생성 -> AT의 델리게이트 구독] -> AT [객체 초기 변수 설정]
2. GA [AT의 활성화 ReadyForActivation] -> AT [Activate 호출 -> 태스트 수행 시작 -> 대기 상태 설정 SetWasitingOnAvatar]
3. AT [태스크 종료 -> 델리게이트 브로드캐스트] -> GA [EndAbility]


AT를 블루프린트에서 호출을 위한 제작 규칙
----------------------------------------------------------------------------
ㅇ기본적으로 AT는 C++에서만 사용 가능 
ㅇstatic 함수에 UFUNCTION(BlueprintCallable)을 지정
ㅇ콜백을 위한 델리게이트는 Dynamic Delegate로 선언
ㅇAT의 델리게이트에 UPROPERTY(BluepirntAssignable)을 지정


언리얼 C++ 팁 
----------------------------------------------------------------------------
<?> const override 
   virtual bool CanActivateAbility(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo,
      const FGameplayTagContainer* SourceTags = nullptr, const FGameplayTagContainer* TargetTags = nullptr, OUT FGameplayTagContainer* OptionalRelevantTags = nullptr) const override;

오버라이드 함수 내에서 객체의 상태를 변경하지 않음






5강. 공격 판정 시스템의 구현
===========================================================================================================
강의목표
----------------------------------------------------------------------------
게임플레이 이벤트를 사용해 게임플레이 어빌리티를 트리거하는 방법의 학습
타겟액터를 사용한 물리 판정의 구현
   - 공격판정을 GA로 구현하여 의존성 제거
어빌리티 태스크와 타겟액터 사이에 발생하는 실행 흐름의 이해


강의내용
----------------------------------------------------------------------------
ㅇ이번 강의에서 진행할 핵심 컴포넌트
   + 게임플레이 이벤트

ㅇ애니메이션 노티파이 설정
   1. AnimNotify를 상속받는 C++ 생성 [AnimNotify_GASAttackHitCheck]
   2. ArenaBattleGAS/Animation의 AM_ComboAttack 몽타주 설정
      - Notifies들 AnimNotify_GASAttackHitCheck로 세팅
      - 태그 추가
         .Project Settings / GameplayTags -> Character.Action.AttackHitCheck
      - 세팅한 AnimNotify_GASAttackHitCheck로의 태그를 추가한 AttackHitCheck로 세팅

ㅇ공격 판정 GA 생성 및 태그 세팅
   3. GameplayAbility를 상속받는 C++ 생성 [ABGA_AttackHitCheck]   
   4. ABGA_AttackHitCheck를 상속받는 블루프린트 생성 [BPGA_AttackHitCheck]
      - Triggers / Ability Triggers에 AttackHitCheck 태그 추가
      ★ 몽타주의 AttackHitCheck태그가 설정된 Notify가 발생하면 ASC는 자동으로 AttackHitCheck태그 트리거로 설정된   
         BPGA_AttackHitCheck GA를 활성화 시킨다. 
   5. BP_ABGASCharacterPlayer의 Start Abilities에 추가 
      - 애니메이션 노티파이로 활성화 하기 위해, ASC에 자동 장착되도록 설정 

ㅇ공격 판정 AT, TA 생성 
   6. AbilityTask를 상속받는 C++생성 [ABAT_Trace]
   7. GameplayAbilityTargetActor를 상속받는 C++ 생성 [ABTA_Trace]
      1) 가장먼저 StartTargeting()에서, TargetActor의 멤버변수인 SourceActor를 초기화 
      2) ConfirmTargetingAndContinue()에서, 타겟 데이터 핸들 생성,
         TargetActor에서 지원하는 TargetDataReadyDelegate를 사용해 타겟 데이터 핸들 브로드캐스트
      3) MakeTargetDta() 구현
         .SweepSingleByChannel()로 충돌 -> 타겟 데이터들을 핸들에 추가 
         .데이터 핸들로 Add시, TSharedPtr를 사용해서 추가 해줌으로, 래퍼런스가 유지되는한 객체가 삭제되지 않음
 
   8. ADAT_Trace에서 TA의 TargetDataReadyDelegate를 구독
      - FTraceResultDelegate(OnComplete) 델리게이트에 타겟 데이터 핸들 파라미터를 추가하여, GA로 전달할수 있게 변경

   9. AT의 CreateTask()에서,어떤 TA를 생성할지 인자로 받도록 변경 + 전달 받은 TA클래스 정보 및 생성한 인스턴스를 저장할 변수 생성
   
   10. AT에 TA를 지연생성 + TargetDataReadyDelegate 구독
   
   11. TA 생성 완료 함수 구현(TA.FinishSpawning()호출), ASC의 TA관리용 TArray에 등록
      - ASC->SpawnedTargetActors.Push(SpawnedTargetActor);

   12. ABGA_AttackHitCheck GA에 AT의 FTraceResultDelegate(OnComplete) 콜백 함수 생성

   13. GA에서 AT 생성(UABAT_Trace::CreateTask()) -> 델이게이트 구독 -> AT 발동 (AttackTraceTask->ReadyForActivation())


모듈에 따른 실행 순서
----------------------------------------------------------------------------
ㅇVS, Rider에서 ArenaBattleGAS.uproject을 클릭해보면 아래와 같이 확인 가능 
	"Modules": [
		{
			"Name": "ArenaBattle",
			"Type": "Runtime",
			"LoadingPhase": "Default",
			"AdditionalDependencies": [
				"Engine"
			]
		},
		{
			"Name": "ArenaBattleGAS",
			"Type": "Runtime",
			"LoadingPhase": "PostDefault",
			"AdditionalDependencies": [
				"Engine",
				"GameplayAbilities",
				"ArenaBattle"
			]
		}
	],

ㅇArenaBattle -> ArenaBattleGAS 순으로 실행되기 때문에 

ㅇArenaBattle/ABCharacterBase에서 몽타주를 시작과 동시에 실행하면,
  ArenaBattleGAS/AnimNotify_GASAttackHitCheck는 로딩 전이기 때문에 감지할 수 없음.

ㅇ몽타주 로직을 ABCharacterBase -> ABGASCharacterPlayer로 이전하여 해결


게임플레이 어빌리티 타겟 액터 TA
----------------------------------------------------------------------------
ㅇGA에서 대상에 대한 판정(주로 물리판정)을 구현할 때 사용하는 특수한 액터
ㅇAGameplayAbilityTargetActor 클래스를 상속받아 구현 

ㅇ왜 TA가 필요한가? 
   - 타겟을 설정하는 다양한 방법이 구현되어 있음
   - Trace를 사용해 즉각적으로 타겟을 검출하는 방법
   - 사용자의 최종 확인을 한번 더 거치는 방법이 있음 (ex. 원거리 범위 공격)
   - 공격 범위 확인을 위한 추가 시각화 (시각화를 수행하는 액터를 월드레티클(WorldReticle)이라 한다)

ㅇ주요 함수
   - StartTargeting: 타겟팅 시작
   - ConfirmTargetingAndContinue: 타겟팅을 확정하고 남은 프로세스 진행
   - ConfirmTargeting: 태스크 진행 없이 타겟팅만 확정
   - CancelTargeting: 타겟팅 취소


게임플레이 어빌리티 타겟 데이터
----------------------------------------------------------------------------
ㅇ타겟 액터에서 판정한 결과를 담은 데이터
ㅇ 다음의 속성을 가지고 있음
   - Trace 히트 결과 (HitResult)
   - 판정된 다수의 액터 포인터
   - 시작 지점
   - 끝 지점
ㅇ 타겟 데이터를여러개 묶어 전송하는 것이 일반적인데 이를 타겟 데이터 핸들이라고 함


★AT와 TA사이의 실행 흐름 
----------------------------------------------------------------------------
AT [TA 지연 생성(SpawnActorDeferred)
   ↓
TA의 타겟팅 결과 델리게이트 구독
   ↓
TA 생성 마무리 (FinishSpawning)]
   ↓
TA [액터 초기 변수 설정 -> 타겟팅 시작(StartTargeting) -> 소스 액터의 설정(필요시 렡티클 엑터 생성)]
   ↓
TA [타겟의 컨펌(ConfirmTargeting) -> 최종 타겟 데이터 생성 -> TargetDataReady 델리게이트를 통한 최종 타겟 데이터 전달]
   ↓
AT [EndTask]

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ABGA_AttackHitCheck::ActivateAbility()
         UABAT_Trace* AttackTraceTask = UABAT_Trace::CreateTask(this, AABTA_Trace::StaticClass());
         AttackTraceTask->OnComplete.AddDynamic(this, &UABGA_AttackHitCheck::OnTraceResultCallback);
         AttackTraceTask->ReadyForActivation();
   ↓
ABAT_Trace::Activate()
         //TA 지연 생성, TargetDataReadyDelegate 구독
         SpawnedTargetActor = Cast<AABTA_Trace>(Ability->GetWorld()->SpawnActorDeferred<AGameplayAbilityTargetActor>
                                 (TargetActorClass, FTransform::Identity, nullptr, nullptr, ESpawnActorCollisionHandlingMethod::AlwaysSpawn));
         SpawnedTargetActor->TargetDataReadyDelegate.AddUObject(this, &UABAT_Trace::OnTargetDataReadyCallback);
         SpawnedTargetActor->FinishSpawning(SpawnTransform);

         //ASC의 TA관리용 TArray에 등록
         ASC->SpawnedTargetActors.Push(SpawnedTargetActor);
         SpawnedTargetActor->StartTargeting(Ability);
         SpawnedTargetActor->ConfirmTargeting();
   ↓
ABTA_Trace::StartTargeting()
ABTA_Trace::ConfirmTargetingAndContinue()
         FGameplayAbilityTargetDataHandle DataHandle = MakeTargetData();
         TargetDataReadyDelegate.Broadcast(DataHandle);
   ↓ TargetDataReadyDelegate   
ABAT_Trace::OnTargetDataReadyCallback()
		   OnComplete.Broadcast(DataHandle);
         EndTask();
   ↓ OnTraceResultCallback
ABGA_AttackHitCheck::OnTraceResultCallback()
	      EndAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, bReplicatedEndAbility, bWasCancelled);
   ↓
ABAT_Trace::OnDestroy()
   		SpawnedTargetActor->Destroy();






6강. 캐릭터 어트리뷰트 설정
===========================================================================================================
강의목표
----------------------------------------------------------------------------
다른 GAS 액터의 상황을 확인할 수 있는 디버그 시스템 설정 방법 학습 
기본 캐릭터 어트리뷰트 설정 방법 학습 
공격 대상의 어트리뷰트 값을 변경하는 방법 학습 
특정 어트리뷰트 변경 시 사전, 사후 점검 방법 학습


강의내용변경  
----------------------------------------------------------------------------
ㅇ 이번 강의에서 진행할 핵심 컴포넌트 
   - 어빌리티 시스템 컴포넌트
   - 게임플레이 어트리뷰트 데이터
   ★ 어트리뷰트 세트


1. ABCharacterNonPlayerCharacter를 상속받는 C++ 생성 [ABGASCharacterNonPlayer]

2. ATtributeSet을 상속받는 C++ 생성 [ABCharacterAttributeSet]
   - AttributeSet에서 제공하는 ATTRIBUTE_ACCESSORS매크로 적용, 한번에 멤버변수들을 다룰수있게 

3. ABGASCharacterNonPlayer에 GAS 시스템 적용

4. ABGASCharacterNonPlayer, ABGASPlayerState에 AttributeSet 생성
 
5. 인게임에서 page up, down키로 태그 디버깅 대상을 변경 가능, NPC의 태그도 디버깅 가능하게 변경 
   - Config/DefaultGame.ini
         [/Script/GameplayAbilities.AbilitySystemGlobals]
         bUseDebugTargetFromHud=True

6. ABTA_Trace의 AttackRange, AttackRadius 하드코딩된 부분을, 어트리뷰트 셋을 사용하도록 변경

7. ABGA_AttackHitCheck::OnTraceResultCallback()에서 감지된 타겟 ASC에게 데미지
   - 대상 Actor에서 ASC를 가져오는 법
   		UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(HitResult.GetActor());
   <?> GA에서 자신을 소유한 ASC를 가져오는 방법? 
    		UAbilitySystemComponent* SourceASC = GetAbilitySystemComponentFromActorInfo_Checked();
   - ABCharacterAttrivuteSet::PreAttributeChange()에서 HP가 0이하로 떨어지지 않게 


어트리뷰트 세트 (Attribute Set)
----------------------------------------------------------------------------
ㅇ단일 어트리뷰트 데이터인 GameplayAttributeData의 묶음 

ㅇGameplayAttributeData는 하나의 값이 아닌 두 가지 값을 구성되어 있음 
   - BaseValue: 기본값. 영구히 적용되는 고정 스탯 값을 관리하는데 사용
   - CurrentValue: 변동값, 버프(Buff) 등으로 임시적으로 변동된 값을 관리하는데 사용

ㅇ어트리뷰트 세트의 주요 함수
   - PreAttributeChange: 변경 전에 호출
   - PostAttributeChange: 변경 후에 호출
   - PreGameplayEffectExecute: 게임플레이 이펙트 적용 전에 호출
   - PostGameplayEffectExecute: 게임플레이 이펙트 적용 후에 호출

ㅇ어트리뷰트 세트 접근자 매크로 
   - 많이 수행되는 기능에 대해 매크로를 만들어 제공 

ㅇASC는 초기화될 때 같은 액터에 있는 UAttributeSet 타입 객체를 찾아서 등록함 
   - 별도로 등록할 필요 없음.
   - 하위 어트리뷰트 셋을 긁어올 때, AddUnique()를 사용하기 때문에 중복된 어트리뷰트셋을 선언 할수 없다. 







7강. 게임플레이 이펙트의 활용
===========================================================================================================
강의목표
----------------------------------------------------------------------------
게임플레이 이펙트의 다양한 활용 방법에 대한 이해
데이터 태그의 설정과 활용 방법의 학습 
메타 어트리뷰트의 설정과 활용 방법의 학습 
레벨에 따른 커브 데이터의 설정과 활용방법의 학습 


강의내용변경  
----------------------------------------------------------------------------
ㅇ 이번 강의에서 구현할 기능 
   - 콤보 공격 히트시 뒤로 갈 수록 전달하는 데미지가 증가하도록 설정 
   - 레벨에 따라 스폰된 캐릭터가 다른 체력값을 가지도록 설정


ㅇ C++로 GE 구현 및 적용 (비효율적인 방법)
   1. GameplayEffect를 상속받는 C++ 생성 [ABGE_AttackDamage]
    - AttributeSet변경을 위한 Modifier 정의
 
   2. ABGA_AttackHitcheck::OnTraceResultCallback()에서 GE 발동
   		FGameplayEffectSpecHandle EffectSpecHandle = MakeOutgoingGameplayEffectSpec(AttackDamageEffect);
       ApplyGameplayEffectSpecToTarget(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, EffectSpecHandle, TargetDataHandle);

   3. BPGA_AttackHitCheck의 GAS/AttackDamageEffect에 ABGE_AttackDamage 세팅

ㅇ블루프린트를 사용하여 GE 적용 (언리얼에서 블루프린트에서 작업하기 편하게 만들어둬 굳이 C++이 아니여도 딸각으로 모든 기능 사용가능)
   4. GameplayEffect를 상속받는 블루프린트 생성 [BPGE_AttackDamage]
      - BPGA_AttackHitCheck의 GAS/AttackDamageEffect에 BPGE_AttackDamage 세팅

   5. GE의 Magnitude Calculation Type: Set by Caller 사용 
      - Project Settings / GameplayType / Gameplay Tag List에 Data.Damage 태그 추가
      - BPGE_AttackDamage의 Set by Caller Magnitude / Data Tag에 Data.Damgae 세팅 

   6. GE의 Magnitude Calculation Type: Custom Calculation Class 사용 
      - GameplayModeMagnitudeCalculation을 상속받는 블루프린트 생성 [BP_AttackDamageCal]
         .FUNCTIONS/ override / Caculate Base Magnitude 선택
      -BPGE_AttackDamage의 Custom Magnitude / Calcuation Class에 생성한 BP_AttackDamgaeCal

   7. GE의 Magnitude Calculation Type: Attribute Based
      - Attribute Based Magnitude / Backing Attribute
         .Attribute to Capture: ABCharacterAttributeSet.AttackRate 
         .Attribute Sourece(누구의 Attribute인지): Source  

ㅇ 메타 어트리뷰트를 사용하여 직접 HP에 접근하던 부분 제거, 데미지를 통해 계산되도록 변경
   8. ABCharacterAttributeSet에 Damage 로직 추가 
      <~> 캐릭터 스탯에 계산을 위한 데이터인, Damage가 들어가는건...

   9. Attribute Set 변경은 직접 접근이 아닌, 오직 GE를 통해서만 
     - Attribute Set을 직접접근하는 ABCharacterAttributeSet::PostAttributeChange() 함수 제거

   10.BPGE_AttackDamage에서 Health를 직접 접근하지 않게 Damage로 변경

ㅇ 콤보공격시 데미지 증가, 커브테이블로 데이터 관리 및 GE에서 사용 
   11. 커브 테이블 생성 및 애니메이션 노티파이에 적용 
      - Miscellaneous / Curve Table [ComboDamageTable]
      - 애니메이션 노타피아이 프로퍼티 추가, ComboDamageTable의 값을 인자로 추가 
            FGameplayEventData PayloadData;
            PayloadData.EventMagnitude = ComboAttackLevel;
   12.ABGA_AttackHitCheck에 레벨 변수 추가 
      - ABGA_AttackHitCheck::ActivateAbility()에서 EventMagnitude를 받아서 저장 
         	CurrentLevel = TriggerEventData->EventMagnitude;
   13.AM_ComboAttack의 Notifies에 ComboAttackLevel 세팅
   14.BPGE_AttackDamage의 Coefficient에 ComboADamage 세팅

ㅇ캐릭터 레벨에 따른 스탯 적용 - GA를 발동시키지 않아도 ASC에서 GE를 발동시켜 초기스텟을 지정하도록 설계
   15. GameplayEffect를 상속받는 블루프린트 생성 [BPGE_CharacterStat]
   16. ABGASCharacterNonPlayer를 상속받은 블루프린트 생성 [BP_ABGASCharacterNonPlayer]
      .씬에 배치
   17. ABGASCharacterNonPlayer에 시작시 발동시킬 GE 관리용 변수 추가
      - GameplayEffectcontextHandle 생성 후 -> GameplayEffectSpecHandle 생성
      - 씬에 배치한 NonPlayer, Init Stat Effect 및 레벨 세팅 



게임플레이 이펙트 GE, Gameplay Effect 
----------------------------------------------------------------------------
ㅇGAS는 게임에 영향을 주는 객체를 별도로 분리해서 관리 
ㅇ영향을 준다는것은 대부분 게임 데이터 변경 작업 -> GE와 어트리뷰트는 함께 동작하도록 구성되어 있다.
ㅇ타입 
   - Instant: 어트리뷰트에 즉각적으로 적용되는 GE, 한프레임에 실행
   - Duration: 지정한 시간 동안 동작하는 GE
   - Infinite: 명시적으로 종료하지 않으면 계속 동작하는 게임플레이 이펙트 
ㅇ타입외에도 다양한 옵션들 제공 

<?>GE의 경우 효과 로직들을 대상에서 돌아간다고 생각해야함.


게임플레이 이펙트 모디파이어 (Modifier)
----------------------------------------------------------------------------
ㅇGE에서 어트리뷰트의 변경 방법을 지정한 설정을 모디파이어라고 한다.

ㅇ모디파이어의 사용 방법
   - 적용할 어트리뷰트 지정
   - 적용 방식의 설정: 더하기, 곱하기, 나누기, 덮어쓰기

ㅇ모디파이어의 계산 방법
   - ScalableFloat: 실수값 대입 (데이터 테이블과 연동 가능)
   - AttributeBased: 특정 어트리뷰트에 기반
   - CustomCalculationClass: 계산을 담당하는 전용 클래스의 활용
   - SetByCaller: 데이터 태그를 활용한 데이터 전달 (전달하는 쪽에서 계산완료후 받는 대상은 값 대입만 진행)

ㅇ모디파이어 없이 자체 계산 로직을 만드는 것도 가능 (GameplayEffectExecutionCalculation)

ㅇ모디파이어는 C++로 설정하기에는 문법이 복잡해서, 블루프린트로 제작하는것을 권장


메타(Meta) 어트리뷰트
----------------------------------------------------------------------------
ㅇ어트리뷰트의 설정을 위해 사전에 미리 설정하는 임시 어트리뷰트 
   - ex. 체력을 바로 깍지 않고, 데미지를 통해 체력을 감소하돌고 설정
      .체력: 일반 어트리뷰트 / 데미지: 메타 어트리뷰트
      .회복,데미지등의 증가감소 둘 다 체력에 직접 접근 하지않고 감소는 오직 데미지 로직을 통해서만 하도록 분리 
   - 임시 어트리뷰트로, 유연한 대처 가능 (무적, 실드, 보정치 등)
   - 메타 어트리뷰트는 적용 후 바로 0으로 값을 초기화하도록 설정
   - 메타 어트리뷰트는 리플레케이션에서 제외시키는것이 일반적
      .네트웍 멀티플레이에서 메타어트리뷰트의 값 (계산 전, 계산 과정 등)을 클라이언트에 숨기고 최종 결과(Hp)만을 전송


레벨가 커브 테이블
----------------------------------------------------------------------------
ㅇGE는 레벨정보 지정 가능, 레벨 정보를 사용해 데이터 테이블의 값들을 가져올 수 있다.
ㅇScalableFloat 모디파이어 타입에서 이를 사용 가능 
ㅇ커브테이블은 언리얼 에디터에서 제작 가능


GE의 생성 과정 
----------------------------------------------------------------------------
ㅇ두가지 데이터로 구성 
   - 게임플레이 이펙트 컨텍스트: 계산에 필요한 데이터를 담은 객체
      .ex 가해자(Instigator), 가해수단(Causer), 판정정보(HitResult) 등
   - 게임플레이 이펙트 스펙: 관련된 정보를 담은 객체 + 게임플레이 이펙트 컨택스트 핸들 정보
      .ex 레벨, 변경스킬 정보를 담은 모디파이어 및 각종 태그에 대한 정보
   
ㅇ 두 데이터는 핸들 각 핸들을 가지며, ASC는 두 데이터를 직접 접근하지 않고 핸들 객체를 통해 간접적으로 관리
   - GameplayEffectSpecHandle
   - GameplayEffectcontextHandle 
   
ㅇ GameplayEffectcontextHandle 생성 후 -> GameplayEffectSpecHandle이 생성된다.


오류 상황 
----------------------------------------------------------------------------
ㅇ현상: BPGE_CharacterStat GE발동으로 스탯 초기화 시 Health:100 / MaxHealth:300 인 상황 발생 
ㅇ원인
   BPGE_CharacterStat을 작성할 때
   ABCharacterAttributeSet.Health를 인덱스 0에 넣고 
   ABCharacterAttributeSet.MaxHealth를 인덱스 1에 넣었더니 
   ABCharacterAttributeSet.Health를 레벨 데이터로 적용시 MaxHealth가 아직 이전 값이라 
   Clamp로 막히는 경우 발생 



Final
----------------------------------------------------------------------------
ㅇ 데미지를 AttributeSet에 넣고 계산후 0으로 리셋 시켜주지말고 
   - 별도로 분리해서 아예 휘발성 데이터로 관리하는게 좋아보임

ㅇ 커브테이블을 통해 레벨 데이터 수정사항을 git으로 관리 가능 -> ER의 데이터시트의 단점 제거 
   - 단 로컬에 데이터파일이 있게 되는거 아닌가? 악의적인 수정이 가능한거 아닌지 확인 필요 







8강. 어트리뷰트와 UI연동
===========================================================================================================
강의목표
----------------------------------------------------------------------------
GAS와 연동하는 UI시스템 구현 방법의 학습
액터 컴포넌트에서 GAS에서 필요한 이벤트만 받아 처리하는 방법 학습    
일정 기간 동안 유지되는 기간형 게임플레이 이펙트의 다양한 활용


강의내용변경
----------------------------------------------------------------------------
ㅇ 이번 강의에서 구현할 기능 
   - 현재 체력 퍼센티지를 표시해주는 체력바 UI의 추가
   - 체력이 떨어지면 죽는 기능 구현
   - 발동 기간동안 들어오는 데미지를 모두 무효화하는 무적 버프의 구현
   - 공격 명중 시 공격 반경이 넓어지는, 최대 4단계 까지 중첩되는 버프의 구현


ㅇ 캐릭터 상단 UI 구현 
   1. UI 관련 C++ 생성 
      - WidgetComponent를 상속받는 C++ 생성 [ABGASWidgetComponent]
      - UserWidget을 상속받는 C++ 생성 [ABGASUserWidget]
      - ABGASUserWdiget을 상속받는 C++ 생성 [ABGASHpBarUserWidget]

   2.ABGASHpBarUserWidget::SetAbilitySystemComponent()에서 GA의 특정 이벤트를 가져와서 구독, 콜백함수에서 UI 갱신
         ASC->GetGameplayAttributeValueChangeDelegate(UABCharacterAttributeSet::GetHealthAttribute()).AddUObject(this, &UABGASHpBarUserWidget::OnHealthChanged);
	   	ASC->GetGameplayAttributeValueChangeDelegate(UABCharacterAttributeSet::GetMaxHealthAttribute()).AddUObject(this, &UABGASHpBarUserWidget::OnMaxHealthChanged );

   3. ABGASCharacterPlayer에서 Mesh에 HpBar위잿 생성 및 부착
      - 호출 스택 
         ABGASCharacterPlayer::AABGASCharacterPlayer()
            	HpBar = CreateDefaultSubobject<UABGASWidgetComponent>(TEXT("Widget"));
            ↓
         ABGASWidgetComponent::InitWidget()
            	UABGASUserWidget* GASUserWidget = Cast<UABGASUserWidget>(GetWidget());
               GASUserWidget->SetAbilitySystemComponent(GetOwner());
            ↓
         ABGASUserWidget::SetAbilitySystemComponent()
      		   ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(InOwner);
            ↓ override
         ABGASHpBarUserWidget::SetAbilitySystemComponent()
               ASC->GetGameplayAttributeValueChangeDelegate(UABCharacterAttributeSet::GetHealthAttribute()).AddUObject(this, &UABGASHpBarUserWidget::OnHealthChanged);
               ASC->GetGameplayAttributeValueChangeDelegate(UABCharacterAttributeSet::GetMaxHealthAttribute()).AddUObject(this, &UABGASHpBarUserWidget::OnMaxHealthChanged );
               CurrentHealth = CurrentAttributeSet->GetHealth();
               CurrentMaxHealth = CurrentAttributeSet->GetMaxHealth();


   4.NPC에도 Hpbar 위젯 적용

ㅇ Hp가 0어 되면 Dead
   5. ABCharacterAttributeSet에 Dead 관련 변수, 델링게이트 추가
      -	mutable FOutOfHealthDelegate OnOutOfHealth;	//const에서 예외 (constCast로 다시 캐스팅하는 과정 mutable로 대체)
      
   6. IsDead 태그 추가
      - DefaultGameplayTags.ini
            +GameplayTagList=(Tag="Character.State.IsDead",DevComment="")
      - ABGameplayTag.h
            #define ABTAG_CHARACTER_ISDEAD FGameplayTag::RequestGameplayTag(FName("Actor.State.IsDead"))
      -ABCharacterAttributeSet::PostGameplayEffectExecute()에서 죽은 대상에게 태그 부여
      		//8-6 Target에 IsDead 태그를 넣어준다.
		      Data.Target.AddLooseGameplayTag(ABTAG_CHARACTER_ISDEAD);
		
   7.각 캐릭터에서 콜백함수 추가, 델리게이트 구독
      <?> 델리게이트 구독때 ThisClass를 사용할수도 있다. 가독성을 해쳐서 지금가지 안섰던 걸까?
      	AttributeSet->OnOutOfHealth.AddDynamic(this, &ThisClass::OnOutOfHealth);

ㅇ 캐릭터에게 무적상태 부여
   8. Project Settings / GameplayTag에 Character.State.Invinsible 추가

   9. GameplayEffect를 상속받는 블루프린트 생성 [BPGE_Invincible]
      - Duration Policy: Has Duration
      - Duration Magnitude / Scalable Float Magnitude: 3.0
      - Tags / GrantedTags: Character.State.Invinsible

   10. GameplayAbility를 상속받는 블루프린트 생성 및 그래프 작업 [BPGA_Invinsible]

   11. NP_ABGASCharacterNonPlayer에서 NPC가 시작할때 무적상태가 되도록 그래프 작업 

ㅇ 무적상태일 때 HPBar UI를 파란색으로 표시
   12.ABGameplayTags.h에 Character.State.Invinsible 추가 
   
   13.ABGASHpBarUserWidget에 색상 기능 추가, 언리얼이 제공하는 태그 델리게이트(RegisterGameplayTagEvent)를 사용하여 이벤트 등록  
         ASC->RegisterGameplayTagEvent(ABTAG_CHARACTER_INVINSIBLE, EGameplayTagEventType::NewOrRemoved).AddUObject(this, &UABGASHpBarUserWidget::OnInvinsibleTagChanged);

ㅇ 무적상태일 때(Invinsible Tag가 활성화 되어 있는 동안) 데미지 무력화
   14. ABCharacterAttributeSet.PreGameplayEffectExecute()에서 구현

ㅇ 기간형 GE를 사용하여 공격 범위 버프 구현
   15. GameplayEffect를 상속받는 블루프린트 생성 [BPGE_AttackHitBuff]
      - Duration Policy: Has Duration
      - Duration Magnitude / Scalable Float Magnitude: 2.0
      - Modifiers / Attribute: ABCharacterAtrributeSet.AttackRadius
      - Modifiers / Scalable Float Magnitude: 15
      - Stacking / Stacking Type: Aggregate by Source (자기 자신의 스택을 기준)
      - Stacking / Stack Limit Count: 4


   16.ABGA_AttackHitcheck에 공격 성공시 버프를 주는 GE 생성 및 적용

   17.BPGA_AttackHitCheck의 Attack Buff Effect: BPGE_AttackHitBuff


기간형 게임플레이 이펙트
----------------------------------------------------------------------------
ㅇ인스턴트 타입이 아닌 GE 게임플에이 이펙트 
   - Duration: 지정 시간 동안 동작
   - Infinite: 명시적으로 종료하지 않으면 계속 동작
ㅇ인스턴트 타입은 한 프레임에 종료되기 때문에, 상태를 가질 수 없음
ㅇ기간형 GE는 유효기단동안 태그와 같은 상태를 가질 수 있음
ㅇ기간형 GE는 중첩(Stack)이 가능하도록 설정 가능 
ㅇ모디파이어를 설정하지 않아도 활용 가능 
ㅇ인스턴트는 Base값을 변경하지만, 기간형은 Current값을 변경하고 원래대로 돌려놓음








9강. 아이템 상자 구현
===========================================================================================================
강의목표
----------------------------------------------------------------------------
장식 이펙트를 잠당하는 게임플레이 큐의 활용 방법의 학습 
기간형 게임플레이 이펙트를 활용한 다양한 아이템 상자의 구현 
GAS의 다양한 API를 활용한 무기에 관련된 게임 플레이 이벤트와 어트리뷰트의 설정


강의내용변경
----------------------------------------------------------------------------
ㅇ 이번 강의에서 구현할 기능 
   - 데미지, 회복 상자의 구현
   - 체력 리젠(Regeneration) 상자, DOT(Damage over time) 상자의 구현 
   - 캐릭터에 무기 추가 


ㅇ Gameplay Tag로 발동되는 GC 제작
   0. Content Browser / Add / Add Feature or Content Pack / Content / Starter Content 추가

   1. GameplayCueNotify_Static를 상속받는 C++ 생성 [ABGC_AttackHit]

   2. Project Settings / GameplayTags  GameplayCue.Character.AttackHit 추가
      - ABGamePlayTag.h에 추가

   3. ABGA_AttackHitCheck::OnTraceResultCallback()에서 적중시 태그 활성화
            FGameplayEffectContextHandle CueContextHandle = UAbilitySystemBlueprintLibrary::GetEffectContext(EffectSpecHandle);
            //MakeOutgoingGameplayEffectSpec로 생성했을때 세부적인 값들은 지정해주지 않고 있음으로 현재 비어있는 상태 -> 직접 채워넣어 준다
            CueContextHandle.AddHitResult(HitResult);
            FGameplayCueParameters CueParam;
            CueParam.EffectContext = CueContextHandle;

            TargetASC->ExecuteGameplayCue(GAMEPLAYCUE_CHARACTER_ATTACKHIT, CueParam);

   4. ABGC_AttackHit을 상속받는 블루프린트 생성 [BPGC_AttackHit]

ㅇ 아이템 상자 제작 
   5. Actor를 상속받는 C++ 생성 [ABGASItemBox]
      - ASC 구성, 기본 컴포넌트 및 충돌시 제거 구현

   6. 충돌시 GC 발동 (이펙트 발동)
      - GameplayCue.Chest.Open 게임플레이 태그 추가
      - GameplayCueNotify_Static을 상속받는 블루프린트 생성 [BPGC_ChestOpen]
         .Gameplay Cue Tag: GameplayCue.Chest.Open로 변경
         .My Blueprint / FUNCTIONS에 마우스 오버 / Override / OnExecute 선택

   7. 충돌시 발동할 각종 GE 생성 (기능 발동)
      - Gameplay Effect를 상속받는 블루프린트 생성 [BPGE_Damage]
      - Gameplay Effect를 상속받는 블루프린트 생성 [BPGE_Heal]
         .Duration Policy: Has Duration
         .Duration Magnitude / Scalable Float Magnitude: 2.0
         .Modifier / Attribute: ABCharacterAttributeSet.Health
         .Modifier / Modifier Magnitude / Scalable Float Magnitude: 20
      - Gameplay Effect를 상속받는 블루프린트 생성 [BPGE_Regen]
         .BPGE_Heal을 복사하여 세팅값 가져온 후
         .Modifier / Modifier Magnitude / Scalable Float Magnitude: 2.0
         .Period / Period: 0.25 //2초동안 0.25초마다 효과 발동
         
      ★기본적으로 Has Duration은 Base가 아닌 Current값을 변경함으로 Duration이 종료되면 효과가 제거되지만 Period 적용시 Base값에 적용되어 Duration이 종료되어도 효과가 남아 있다.

   8. 데미지 GC 
      - BPGC_ChestOpen를 복제하여 블루프린트 생성 [BPGC_Damage]
         .GameplayCue.Character.Damage 게임플레이 태그 추가
         .BPGC_Damage의 Gameplay Cue Tag에 GameplayCue.Character.Damage 설정
      - BPGE_Damage GE의 Display / Gameplay Cues / Gameplay Cue Tags에 GameplayCue.Character.Damage 설정
         -> Tag를 통해 별도 C++작업이 없어도 GE에도 태그를 활성화하면, 자동으로 해당 태그가 설정된 GC가 발동된다.

   9. 무적상태 GE 
      - Gameplay Effect를 상속받는 블루프린트 생성 [BPGE_InvinsibleInf] 
         .Tags / GrantedTags / Added: Character.State.Invinsible
      - BPGE_InvinsibleInf를 복제해 블루프린트 생성 [BPGE_InvinsibleRemove] 
         .Remove Gameplay Effects With Tags / Add: Character.State.Invinsible

   10. 무기 장착 GE 
      - ABGASItemBox를 상속받는 C++ 생성 [ABGASWeaponBox]
         	UAbilitySystemBlueprintLibrary::SendGameplayEventToActor(OtherActor, WeaponEventTag, FGameplayEventData());	
      - DefaultGameplayTags에 태그 추가 
            +GameplayTagList=(Tag="Event.Character.Weapon.Equip", DevComment="")
            +GameplayTagList=(Tag="Event.Character.Weapon.UnEquip", DevComment="")
      - ABGASCharacterPlayer::PossessedBy()에서 전역 GAS 시스템에 해당 태그 이벤트를 구독하겠다고 전달
      	   void EquipWeapon(const FGameplayEventData* EventData);
	         void UnequipWeapon(const FGameplayEventData* EventData);
      		
            ASC->GenericGameplayEventCallbacks.FindOrAdd(ABTAG_EVENT_CHARACTER_WEAPONEQUIP).AddUObject(this, &AABGASCharacterPlayer::EquipWeapon);
      		ASC->GenericGameplayEventCallbacks.FindOrAdd(ABTAG_EVENT_CHARACTER_WEAPONUNEQUIP).AddUObject(this, &AABGASCharacterPlayer::UnequipWeapon);
      - Weapon 장착시 기능 구현, 스켈레탈 메쉬 변경 및 Stat 추가 (시간관계상 ABGASCharacterPlayer에 대충 스탯 변수 추가해서 구현)
         .GE를 사용하지 않고 직접 GA에 접근하여 스탯변경 (바람직한 방법은 아니지만 이런 방법도 있음을 보여주기 위해)



GC 게임플레이 큐 (Cue) 
----------------------------------------------------------------------------
ㅇ 시각 이펙트나 사운드 담당 
ㅇ 데디케이티드 서버에서는 사용할 필요 없음 (ER로 치면 배틀서버)
ㅇ 두 종류
   - 스태틱 게임플레이 큐: 일시적으로 발생하는 특수 효과 (Execute 이벤트) [GameplayCueNotify_Static]
   - 액터 게임플레이 큐: 일정 기간동안 발생하는 특수 효과 (Add/Remove 이벤트) [GameplayCueNotify_Actor]
ㅇ C+로도 구현할 수 있지만, 블루프린트로 제작하는 것이 더 생산적
ㅇ GE에서 자동으로 GC와 연동할 수 있도록 기능 제공 
ㅇ GC의 재생은 GameplayCueManager가 관리 
ㅇ 게임플레이 태그를 사용해 쉽게 발동시킬 수 있음 
   - 이때 반드시 GameplayCue로 시작하는 게임플레이 태그를 사용해야한다.



언리얼 C++ 팁
----------------------------------------------------------------------------
ㅇApplyGameplayEffectSpecToSelf()와 BP_ApplyGameplayEffectSpecToSelf의 차이는 BP가 블루프린트에서 사용가능한 버전이라 편하다는 정도
   - TargetASC->BP_ApplyGameplayEffectSpecToSelf(EffectSpecHandle);  //내부에서 알아서 다함
   - TargetASC->ApplyGameplayEffectSpecToSelf(*EffectSpecHandle.Data.Get());  //내용물이 포인터이기 때문에 빼내와야함



Final
----------------------------------------------------------------------------
9-10. Weapon 장착시 기능 구현, 스켈레탈 메쉬 변경 및 Stat 추가 (시간관계상 ABGASCharacterPlayer에 대충 스탯 변수 추가해서 구현)
   - Part2때처럼 Weapon자체가 Stat을 가지고 있어 Base와 분리, 최종 계산 때 더해지는 방식으로 







10강. 캐릭터의 광역 스킬 구현
===========================================================================================================
강의목표
----------------------------------------------------------------------------
플레이어 캐릭터에 새로운 스킬 GA를 부여, 범위 공격을 추가하도록 설계 확장
새로운 어트리뷰트 세트를 추가해 확장
GA에 사용 비용과 쿨다운의 제약 사항 추가
게임플레이 이펙트 실행 계산 클래스를 사용해 거리에 따른 광역 데미지 감소 적용


강의내용
----------------------------------------------------------------------------

ㅇ 스킬 구현
   1. GameplayAbility를 상속받는 C`++ 생성 [ABGA_Skill]

   2. ABGASCharacterPlayer에 스킬 기능 구현
      - Skill GA 부여, 제거
      - EnhancedInputComponent에 스킬 입력 키 바인딩

   3. ABGA_Skill을 상속받는 블루프린트 생성 [BPGA_Skill]
      - Tags / Activation Blocked Tags에 IsAttack, IsDead, IsJumping 추가하여 해당 태그중에 스킬 태그의 GA 잠금 
      - BP_ABGASCharacterPlayer의 Skill Abilities Class에 BPGA_Skill 세팅
      - Character.State.IsSkilling 게임 플레이 태그 추가 
         .BPGA_Skill의 Activation Blocked Tags에 IsDead, IsJumping, IsSkilling 추가

   4. ABGA_Skill에서 몽타주 재생 및 몽타주 재생동안 움직임 제어 
`
ㅇ스킬 애니메이션 노티파이 설정
   5. 몽타주 노티파이에 태그 세팅
      - Event.Character.Action.SkillHitCheck 게임플레이 태그 추가 
      - AM_SkillAttack의 노티파이에 태그 세팅

   6. BPGA_AttackHitCheck를 복제하여 블루프린트 생성 [BPGA_SkillHitCheck]
      - Ability Tags에 Event.Character.Action.SkillHitCheck 세팅
      - BP_ABGASCharacterPlayer의 Start Abilities에 BPGA_SkillHitCheck 추가

ㅇAABTA_Trace을 상속받아 범위 공격 TA 생성 
   7.ABGA_AttackHitCheck에 AABTA_Trace 변수 추가 
      	//5-12 -> 10-7  AABTA_Trace를 상속받는 범위 공격 TA 생성, 단일 범위 둘 다 올수 있게 AABTA_Trace형 변수로 관리
      	//UABAT_Trace* AttackTraceTask = UABAT_Trace::CreateTask(this, AABTA_Trace::StaticClass());
      	UABAT_Trace* AttackTraceTask = UABAT_Trace::CreateTask(this, TargetActorClass);

   8. AABTA_Trace를 상속받는 C++ 생성 [ABTA_SphereMultiTrace]
      - 범위 충돌 구현 
            //충돌 후 결과를 Overlaps에 임시저장 -> TargetDataHandle에 저장
            TArray<FOverlapResult> Overlaps;``
            const float SkillRadius = 800.0f;
            FVector Origin = Character->GetActorLocation();
            FCollisionQueryParams Params(SCENE_QUERY_STAT(AABTA_SphereMultiTrace), false, Character);	
            GetWorld()->OverlapMultiByChannel(Overlaps, Origin, FQuat::Identity, CCHANNEL_ABACTION, FCollisionShape::MakeSphere(SkillRadius), Params);

            //아래의 FGameplayAbilityTargetData_ActorArray가 TWeakObjectPtr형태임으로 변환해준다.
            TArray<TWeakObjectPtr<AActor>> HitActors;
            for (const FOverlapResult& Overlap : Overlaps)
            {
               AActor* HitActor = Overlap.OverlapObjectHandle.FetchActor<AActor>();
               if (HitActor && !HitActors.Contains(HitActor))
               {
                  HitActors.Add(HitActor);
               }
            }
            
            //FGameplayAbilityTargetData_ActorArray: 다수의 액터를 저장하는 타겟 데이터 타입
            FGameplayAbilityTargetData_ActorArray* ActorsData = new FGameplayAbilityTargetData_ActorArray();
            ActorsData->SetActors(HitActors);``
      - BPGA_SkillHitCheck의 Target Actor Class: ABTA_SphereMultiTrace 로 설정


<?> TWeakObjectPtr처럼, 언리얼 C++의 메모리 관련된 기능들 조사하기


ㅇ 다수의 NPC에 데미지 전달 및 장식 이펙트 부여 
   9. ABGA_AttackHitCheck::OnTraceResultCallback()에서 타겟데이터에 HitResult가 아닌 Actor가 들어온 경우 (범위 공격) 구현
         //10-9 타겟데이터에 HitResult가 아닌 Actor가 들어온 경우 (범위 공격)
         else if (UAbilitySystemBlueprintLibrary::TargetDataHasActor(TargetDataHandle, 0))
         {
            UAbilitySystemComponent* SourceASC = GetAbilitySystemComponentFromActorInfo_Checked();

            FGameplayEffectSpecHandle EffectSpecHandle = MakeOutgoingGameplayEffectSpec(AttackDamageEffect, CurrentLevel);
            if (EffectSpecHandle.IsValid())
            {
               ApplyGameplayEffectSpecToTarget(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, EffectSpecHandle, TargetDataHandle);

               FGameplayEffectContextHandle CueContextHandle = UAbilitySystemBlueprintLibrary::GetEffectContext(EffectSpecHandle);
               CueContextHandle.AddActors(TargetDataHandle.Data[0].Get()->GetActors(), false);
               FGameplayCueParameters CueParam;
               CueParam.EffectContext = CueContextHandle;

               //타겟이 여러명이니 Source에서 진행
               SourceASC->ExecuteGameplayCue(ABTAG_GAMEPLAYCUE_CHARACTER_ATTACKHIT, CueParam);
            }
         }
   10.BPGE_AttackDamage를 복사해 블루프린트 생성 [BPGE_SkillDamage]

   11.ABGC_AttackHit::OnExecute_Implementation()에서 다수의 Actor 이펙트 처리 구현


ㅇ신규 어트리뷰트의 추가 및 활용 
   12. AttributeSet을 상속받는 C++ 생성 [ABCharacterSkillAttributeSet]
      - ABGasPlayerState에 ABCharacterSkillAttributeSet 변수 추가
      - ABTA_SphereMultiTrace에 하드코딩된 수치들 AttributeSet 적용 

   13. ABCharacterSkillAttributeSet에 스킬 에너지 추가


ㅇGA의 Costs와 Cooldowns 기능 사용 
   14. GameplayEffect를 상속받는 블루프린트 생성 [BPGE_SkillCost]
      - BPGA_Skill의 Costs/Cost Gameplay Effect Class: BPGE_SkillCost 세팅

   15. GameplayEffect를 상속받는 블루프린트 생성 [BPGE_SkillCooldown]
      - Character.State.SkillCooldown 게임플레이 태그 세팅
      - BPGE_SkillCooldown의 Tags/Add에 태그 세팅 
      - Has Duration으로 세팅하여 지정 시간동안 태그 활성화
      - BPGA_Skill의 Cooldown / Cooldown Gameplay Effect Class: BPGE_SkillCooldown로 세팅

ㅇ범위 데미지 수동 계산
   16. GameplayEffectExecutionCalculation를 상속받는 C++ 생성 [ABSkillDamageExecutionCalc]
      - BPGE_SkillDamage의 Gameplay Effect / Modifiers 제거 -> Executions에 ABSkillDamageExecutionCalc 세팅



































